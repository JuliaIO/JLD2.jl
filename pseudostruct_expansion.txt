================================================================================
SIMPLE STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestSimple}, hflags, hsize, kw)
        penguin = 1
        version = Main.get(kw, :version, penguin)
        Main.jlwrite(fly, UInt8(version))
        locust = 0
        flags = Main.get(kw, :flags, locust)
        Main.jlwrite(fly, UInt8(flags))
        Main.haskey(kw, :count) || Main.throw(Main.ArgumentError("Argument :count is required"))
        count = kw.count
        Main.jlwrite(fly, UInt32(count))
    end
    function compute_size(::Main.Val{Main.TestSimple}, hflags, hsize, kw)
        offset = 0
        grasshopper = 1
        version = Main.get(kw, :version, grasshopper)
        offset += Main.sizeof(UInt8)
        swan = 0
        flags = Main.get(kw, :flags, swan)
        offset += Main.sizeof(UInt8)
        Main.haskey(kw, :count) || Main.throw(Main.ArgumentError("Argument :count is required"))
        count = kw.count
        offset += Main.sizeof(UInt32)
        return offset
    end
    function messageshow(::Main.Val{Main.TestSimple}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        goosander = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(goosander, :version => version)
        flags = Main.jlread(io, UInt8)
        Main.push!(goosander, :flags => flags)
        count = Main.jlread(io, UInt32)
        Main.push!(goosander, :count => count)
        return goosander
    end
    function Base.getproperty(quelea::Main.HmWrap{Main.TestSimple, sanddollar}, partridge::Main.Symbol) where sanddollar
        partridge == :size && return Main.getfield(quelea, partridge)
        partridge == :hflags && return Main.getfield(quelea, partridge)
        partridge == :m && return Main.getfield(quelea, partridge)
        anteater = Main.getfield(quelea, :m)::Main.Message{sanddollar}
        lark = Main.getfield(quelea, :hflags)
        pheasant = Main.getfield(quelea, :size)
        reindeer = Main.getfield(anteater, :io)::sanddollar
        if partridge == :version
            duck = Main.getfield(anteater, :address)
            Main.seek(reindeer, duck)
            cat = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            return cat
        end
        if partridge == :flags
            duck = Main.getfield(anteater, :address)
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            return elk
        end
        if partridge == :count
            duck = Main.getfield(anteater, :address)
            duck += Main.sizeof(Main.UInt8)
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            leopard = Main.jlread(reindeer, Main.UInt32)::Main.UInt32
            return leopard
        end
        Main.throw(Main.ArgumentError("property $(partridge) not found"))
    end
    Main.nothing
end

================================================================================
CONDITIONAL STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestConditional}, hflags, hsize, kw)
        penguin = 2
        version = Main.get(kw, :version, penguin)
        Main.jlwrite(fly, UInt8(version))
        locust = 0
        flags = Main.get(kw, :flags, locust)
        Main.jlwrite(fly, UInt8(flags))
        isset(flags, 0) && begin
                Main.haskey(kw, :max_value) || Main.throw(Main.ArgumentError("Argument :max_value is required"))
                max_value = kw.max_value
                Main.jlwrite(fly, Int64(max_value))
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :min_value) || Main.throw(Main.ArgumentError("Argument :min_value is required"))
                min_value = kw.min_value
                Main.jlwrite(fly, Int64(min_value))
            end
    end
    function compute_size(::Main.Val{Main.TestConditional}, hflags, hsize, kw)
        offset = 0
        grasshopper = 2
        version = Main.get(kw, :version, grasshopper)
        offset += Main.sizeof(UInt8)
        swan = 0
        flags = Main.get(kw, :flags, swan)
        offset += Main.sizeof(UInt8)
        isset(flags, 0) && begin
                Main.haskey(kw, :max_value) || Main.throw(Main.ArgumentError("Argument :max_value is required"))
                max_value = kw.max_value
                offset += Main.sizeof(Int64)
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :min_value) || Main.throw(Main.ArgumentError("Argument :min_value is required"))
                min_value = kw.min_value
                offset += Main.sizeof(Int64)
            end
        return offset
    end
    function messageshow(::Main.Val{Main.TestConditional}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        goosander = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(goosander, :version => version)
        flags = Main.jlread(io, UInt8)
        Main.push!(goosander, :flags => flags)
        isset(flags, 0) && begin
                max_value = Main.jlread(io, Int64)
                Main.push!(goosander, :max_value => max_value)
            end
        isset(flags, 1) && begin
                min_value = Main.jlread(io, Int64)
                Main.push!(goosander, :min_value => min_value)
            end
        return goosander
    end
    function Base.getproperty(quelea::Main.HmWrap{Main.TestConditional, sanddollar}, partridge::Main.Symbol) where sanddollar
        partridge == :size && return Main.getfield(quelea, partridge)
        partridge == :hflags && return Main.getfield(quelea, partridge)
        partridge == :m && return Main.getfield(quelea, partridge)
        anteater = Main.getfield(quelea, :m)::Main.Message{sanddollar}
        lark = Main.getfield(quelea, :hflags)
        pheasant = Main.getfield(quelea, :size)
        reindeer = Main.getfield(anteater, :io)::sanddollar
        if partridge == :version
            duck = Main.getfield(anteater, :address)
            Main.seek(reindeer, duck)
            cat = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            return cat
        end
        if partridge == :flags
            duck = Main.getfield(anteater, :address)
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            return elk
        end
        if partridge == :max_value
            duck = Main.getfield(anteater, :address)
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            if Main.isset(elk, 0)
                leopard = Main.jlread(reindeer, Main.Int64)::Main.Int64
                return leopard
            end
        end
        if partridge == :min_value
            duck = Main.getfield(anteater, :address)
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            duck += Main.sizeof(Main.UInt8)
            Main.isset(elk, 0) && (duck += Main.sizeof(Main.Int64))
            Main.seek(reindeer, duck)
            if Main.isset(elk, 1)
                dragonfly = Main.jlread(reindeer, Main.Int64)::Main.Int64
                return dragonfly
            end
        end
        Main.throw(Main.ArgumentError("property $(partridge) not found"))
    end
    Main.nothing
end

================================================================================
SPECIAL TYPES STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestSpecial}, hflags, hsize, kw)
        penguin = 1
        version = Main.get(kw, :version, penguin)
        Main.jlwrite(fly, UInt8(version))
        Main.haskey(kw, :name_len) || Main.throw(Main.ArgumentError("Argument :name_len is required"))
        name_len = kw.name_len
        Main.jlwrite(fly, UInt16(name_len))
        Main.haskey(kw, :name) || Main.throw(Main.ArgumentError("Argument :name is required"))
        name = kw.name
        Main.jlwrite(fly, name)
        Main.haskey(kw, :data_size) || Main.throw(Main.ArgumentError("Argument :data_size is required"))
        data_size = kw.data_size
        Main.jlwrite(fly, UInt32(data_size))
        Main.haskey(kw, :data) || Main.throw(Main.ArgumentError("Argument :data is required"))
        data = kw.data
        Main.jlwrite(fly, data)
    end
    function compute_size(::Main.Val{Main.TestSpecial}, hflags, hsize, kw)
        offset = 0
        locust = 1
        version = Main.get(kw, :version, locust)
        offset += Main.sizeof(UInt8)
        Main.haskey(kw, :name_len) || Main.throw(Main.ArgumentError("Argument :name_len is required"))
        name_len = kw.name_len
        offset += Main.sizeof(UInt16)
        Main.haskey(kw, :name) || Main.throw(Main.ArgumentError("Argument :name is required"))
        name = kw.name
        offset += name_len
        Main.haskey(kw, :data_size) || Main.throw(Main.ArgumentError("Argument :data_size is required"))
        data_size = kw.data_size
        offset += Main.sizeof(UInt32)
        Main.haskey(kw, :data) || Main.throw(Main.ArgumentError("Argument :data is required"))
        data = kw.data
        offset += data_size
        return offset
    end
    function messageshow(::Main.Val{Main.TestSpecial}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        grasshopper = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(grasshopper, :version => version)
        name_len = Main.jlread(io, UInt16)
        Main.push!(grasshopper, :name_len => name_len)
        name = Main.String(Main.jlread(io, Main.UInt8, name_len))
        Main.push!(grasshopper, :name => name)
        data_size = Main.jlread(io, UInt32)
        Main.push!(grasshopper, :data_size => data_size)
        data = Main.jlread(io, Main.UInt8, data_size)
        Main.push!(grasshopper, :data => data)
        return grasshopper
    end
    function Base.getproperty(swan::Main.HmWrap{Main.TestSpecial, goosander}, quelea::Main.Symbol) where goosander
        quelea == :size && return Main.getfield(swan, quelea)
        quelea == :hflags && return Main.getfield(swan, quelea)
        quelea == :m && return Main.getfield(swan, quelea)
        sanddollar = Main.getfield(swan, :m)::Main.Message{goosander}
        partridge = Main.getfield(swan, :hflags)
        anteater = Main.getfield(swan, :size)
        lark = Main.getfield(sanddollar, :io)::goosander
        if quelea == :version
            pheasant = Main.getfield(sanddollar, :address)
            Main.seek(lark, pheasant)
            reindeer = Main.jlread(lark, Main.UInt8)::Main.UInt8
            return reindeer
        end
        if quelea == :name_len
            pheasant = Main.getfield(sanddollar, :address)
            pheasant += Main.sizeof(Main.UInt8)
            Main.seek(lark, pheasant)
            duck = Main.jlread(lark, Main.UInt16)::Main.UInt16
            return duck
        end
        if quelea == :name
            pheasant = Main.getfield(sanddollar, :address)
            pheasant += Main.sizeof(Main.UInt8)
            Main.seek(lark, pheasant)
            duck = Main.jlread(lark, Main.UInt16)::Main.UInt16
            pheasant += Main.sizeof(Main.UInt16)
            Main.seek(lark, pheasant)
            cat = Main.String(Main.jlread(lark, Main.UInt8, duck))
            return cat
        end
        if quelea == :data_size
            pheasant = Main.getfield(sanddollar, :address)
            pheasant += Main.sizeof(Main.UInt8)
            Main.seek(lark, pheasant)
            duck = Main.jlread(lark, Main.UInt16)::Main.UInt16
            pheasant += Main.sizeof(Main.UInt16)
            pheasant += duck
            Main.seek(lark, pheasant)
            elk = Main.jlread(lark, Main.UInt32)::Main.UInt32
            return elk
        end
        if quelea == :data
            pheasant = Main.getfield(sanddollar, :address)
            pheasant += Main.sizeof(Main.UInt8)
            Main.seek(lark, pheasant)
            duck = Main.jlread(lark, Main.UInt16)::Main.UInt16
            pheasant += Main.sizeof(Main.UInt16)
            pheasant += duck
            Main.seek(lark, pheasant)
            elk = Main.jlread(lark, Main.UInt32)::Main.UInt32
            pheasant += Main.sizeof(Main.UInt32)
            Main.seek(lark, pheasant)
            leopard = Main.jlread(lark, Main.UInt8, elk)::Main.Vector{Main.UInt8}
            return leopard
        end
        Main.throw(Main.ArgumentError("property $(quelea) not found"))
    end
    Main.nothing
end

================================================================================
NESTED CONDITIONS STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestNested}, hflags, hsize, kw)
        penguin = 3
        version = Main.get(kw, :version, penguin)
        Main.jlwrite(fly, UInt8(version))
        if version == 3
            locust = 0
            flags = Main.get(kw, :flags, locust)
            Main.jlwrite(fly, UInt8(flags))
            isset(flags, 0) && begin
                    Main.haskey(kw, :extra) || Main.throw(Main.ArgumentError("Argument :extra is required"))
                    extra = kw.extra
                    Main.jlwrite(fly, UInt32(extra))
                end
        end
        if version == 2
            Main.haskey(kw, :old_flags) || Main.throw(Main.ArgumentError("Argument :old_flags is required"))
            old_flags = kw.old_flags
            Main.jlwrite(fly, UInt16(old_flags))
        end
    end
    function compute_size(::Main.Val{Main.TestNested}, hflags, hsize, kw)
        offset = 0
        grasshopper = 3
        version = Main.get(kw, :version, grasshopper)
        offset += Main.sizeof(UInt8)
        if version == 3
            swan = 0
            flags = Main.get(kw, :flags, swan)
            offset += Main.sizeof(UInt8)
            isset(flags, 0) && begin
                    Main.haskey(kw, :extra) || Main.throw(Main.ArgumentError("Argument :extra is required"))
                    extra = kw.extra
                    offset += Main.sizeof(UInt32)
                end
        end
        if version == 2
            Main.haskey(kw, :old_flags) || Main.throw(Main.ArgumentError("Argument :old_flags is required"))
            old_flags = kw.old_flags
            offset += Main.sizeof(UInt16)
        end
        return offset
    end
    function messageshow(::Main.Val{Main.TestNested}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        goosander = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(goosander, :version => version)
        if version == 3
            flags = Main.jlread(io, UInt8)
            Main.push!(goosander, :flags => flags)
            isset(flags, 0) && begin
                    extra = Main.jlread(io, UInt32)
                    Main.push!(goosander, :extra => extra)
                end
        end
        if version == 2
            old_flags = Main.jlread(io, UInt16)
            Main.push!(goosander, :old_flags => old_flags)
        end
        return goosander
    end
    function Base.getproperty(quelea::Main.HmWrap{Main.TestNested, sanddollar}, partridge::Main.Symbol) where sanddollar
        partridge == :size && return Main.getfield(quelea, partridge)
        partridge == :hflags && return Main.getfield(quelea, partridge)
        partridge == :m && return Main.getfield(quelea, partridge)
        anteater = Main.getfield(quelea, :m)::Main.Message{sanddollar}
        lark = Main.getfield(quelea, :hflags)
        pheasant = Main.getfield(quelea, :size)
        reindeer = Main.getfield(anteater, :io)::sanddollar
        if partridge == :version
            duck = Main.getfield(anteater, :address)
            Main.seek(reindeer, duck)
            cat = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            return cat
        end
        if partridge == :flags
            duck = Main.getfield(anteater, :address)
            Main.seek(reindeer, duck)
            cat = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            duck += Main.sizeof(Main.UInt8)
            Main.seek(reindeer, duck)
            if cat == 3
                elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
                return elk
            end
        end
        if partridge == :extra
            duck = Main.getfield(anteater, :address)
            Main.seek(reindeer, duck)
            cat = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            duck += Main.sizeof(Main.UInt8)
            if cat == 3
                Main.seek(reindeer, duck)
                elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            end
            cat == 3 && (duck += Main.sizeof(Main.UInt8))
            Main.seek(reindeer, duck)
            if cat == 3 && Main.isset(elk, 0)
                leopard = Main.jlread(reindeer, Main.UInt32)::Main.UInt32
                return leopard
            end
        end
        if partridge == :old_flags
            duck = Main.getfield(anteater, :address)
            Main.seek(reindeer, duck)
            cat = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            duck += Main.sizeof(Main.UInt8)
            if cat == 3
                Main.seek(reindeer, duck)
                elk = Main.jlread(reindeer, Main.UInt8)::Main.UInt8
            end
            cat == 3 && (duck += Main.sizeof(Main.UInt8))
            (cat == 3 && Main.isset(elk, 0)) && (duck += Main.sizeof(Main.UInt32))
            Main.seek(reindeer, duck)
            if cat == 2
                dragonfly = Main.jlread(reindeer, Main.UInt16)::Main.UInt16
                return dragonfly
            end
        end
        Main.throw(Main.ArgumentError("property $(partridge) not found"))
    end
    Main.nothing
end
