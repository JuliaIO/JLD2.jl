================================================================================
SIMPLE STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestSimple}, hflags, hsize, kw)
        default_version = 1
        version = Main.get(kw, :version, default_version)
        Main.jlwrite(fly, UInt8(version))
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        Main.jlwrite(fly, UInt8(flags))
        Main.haskey(kw, :count) || Main.throw(Main.ArgumentError("Argument :count is required"))
        count = kw.count
        Main.jlwrite(fly, UInt32(count))
    end
    function compute_size(::Main.Val{Main.TestSimple}, hflags, hsize, kw)
        offset = 0
        default_version = 1
        version = Main.get(kw, :version, default_version)
        offset += Main.sizeof(UInt8)
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        offset += Main.sizeof(UInt8)
        Main.haskey(kw, :count) || Main.throw(Main.ArgumentError("Argument :count is required"))
        count = kw.count
        offset += Main.sizeof(UInt32)
        return offset
    end
    function messageshow(::Main.Val{Main.TestSimple}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :version => version)
        flags = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :flags => flags)
        count = Main.jlread(io, UInt32)
        Main.push!(keyvalue, :count => count)
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestSimple, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :version
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            return value_version
        end
        if s == :flags
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
            return value_flags
        end
        if s == :count
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_count = Main.jlread(io, Main.UInt32)::Main.UInt32
            return value_count
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end

================================================================================
CONDITIONAL STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestConditional}, hflags, hsize, kw)
        default_version = 2
        version = Main.get(kw, :version, default_version)
        Main.jlwrite(fly, UInt8(version))
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        Main.jlwrite(fly, UInt8(flags))
        isset(flags, 0) && begin
                Main.haskey(kw, :max_value) || Main.throw(Main.ArgumentError("Argument :max_value is required"))
                max_value = kw.max_value
                Main.jlwrite(fly, Int64(max_value))
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :min_value) || Main.throw(Main.ArgumentError("Argument :min_value is required"))
                min_value = kw.min_value
                Main.jlwrite(fly, Int64(min_value))
            end
    end
    function compute_size(::Main.Val{Main.TestConditional}, hflags, hsize, kw)
        offset = 0
        default_version = 2
        version = Main.get(kw, :version, default_version)
        offset += Main.sizeof(UInt8)
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        offset += Main.sizeof(UInt8)
        isset(flags, 0) && begin
                Main.haskey(kw, :max_value) || Main.throw(Main.ArgumentError("Argument :max_value is required"))
                max_value = kw.max_value
                offset += Main.sizeof(Int64)
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :min_value) || Main.throw(Main.ArgumentError("Argument :min_value is required"))
                min_value = kw.min_value
                offset += Main.sizeof(Int64)
            end
        return offset
    end
    function messageshow(::Main.Val{Main.TestConditional}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :version => version)
        flags = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :flags => flags)
        isset(flags, 0) && begin
                max_value = Main.jlread(io, Int64)
                Main.push!(keyvalue, :max_value => max_value)
            end
        isset(flags, 1) && begin
                min_value = Main.jlread(io, Int64)
                Main.push!(keyvalue, :min_value => min_value)
            end
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestConditional, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :version
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            return value_version
        end
        if s == :flags
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
            return value_flags
        end
        if s == :max_value
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            if Main.isset(Main.flags, 0)
                value_max_value = Main.jlread(io, Main.Int64)::Main.Int64
                return value_max_value
            end
        end
        if s == :min_value
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
            offset += Main.sizeof(Main.UInt8)
            Main.isset(Main.flags, 0) && (offset += Main.sizeof(Main.Int64))
            Main.seek(io, offset)
            if Main.isset(Main.flags, 1)
                value_min_value = Main.jlread(io, Main.Int64)::Main.Int64
                return value_min_value
            end
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end

================================================================================
SPECIAL TYPES STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestSpecial}, hflags, hsize, kw)
        default_version = 1
        version = Main.get(kw, :version, default_version)
        Main.jlwrite(fly, UInt8(version))
        Main.haskey(kw, :name_len) || Main.throw(Main.ArgumentError("Argument :name_len is required"))
        name_len = kw.name_len
        Main.jlwrite(fly, UInt16(name_len))
        Main.haskey(kw, :name) || Main.throw(Main.ArgumentError("Argument :name is required"))
        name = kw.name
        Main.jlwrite(fly, name)
        Main.haskey(kw, :data_size) || Main.throw(Main.ArgumentError("Argument :data_size is required"))
        data_size = kw.data_size
        Main.jlwrite(fly, UInt32(data_size))
        Main.haskey(kw, :data) || Main.throw(Main.ArgumentError("Argument :data is required"))
        data = kw.data
        Main.jlwrite(fly, data)
    end
    function compute_size(::Main.Val{Main.TestSpecial}, hflags, hsize, kw)
        offset = 0
        default_version = 1
        version = Main.get(kw, :version, default_version)
        offset += Main.sizeof(UInt8)
        Main.haskey(kw, :name_len) || Main.throw(Main.ArgumentError("Argument :name_len is required"))
        name_len = kw.name_len
        offset += Main.sizeof(UInt16)
        Main.haskey(kw, :name) || Main.throw(Main.ArgumentError("Argument :name is required"))
        name = kw.name
        offset += name_len
        Main.haskey(kw, :data_size) || Main.throw(Main.ArgumentError("Argument :data_size is required"))
        data_size = kw.data_size
        offset += Main.sizeof(UInt32)
        Main.haskey(kw, :data) || Main.throw(Main.ArgumentError("Argument :data is required"))
        data = kw.data
        offset += data_size
        return offset
    end
    function messageshow(::Main.Val{Main.TestSpecial}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :version => version)
        name_len = Main.jlread(io, UInt16)
        Main.push!(keyvalue, :name_len => name_len)
        name = Main.String(Main.jlread(io, Main.UInt8, name_len))
        Main.push!(keyvalue, :name => name)
        data_size = Main.jlread(io, UInt32)
        Main.push!(keyvalue, :data_size => data_size)
        data = Main.jlread(io, Main.UInt8, data_size)
        Main.push!(keyvalue, :data => data)
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestSpecial, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :version
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            return value_version
        end
        if s == :name_len
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_name_len = Main.jlread(io, Main.UInt16)::Main.UInt16
            return value_name_len
        end
        if s == :name
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_name_len = Main.jlread(io, Main.UInt16)::Main.UInt16
            offset += Main.sizeof(Main.UInt16)
            Main.seek(io, offset)
            value_name = Main.String(Main.jlread(io, Main.UInt8, Main.name_len))
            return value_name
        end
        if s == :data_size
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_name_len = Main.jlread(io, Main.UInt16)::Main.UInt16
            offset += Main.sizeof(Main.UInt16)
            offset += Main.name_len
            Main.seek(io, offset)
            value_data_size = Main.jlread(io, Main.UInt32)::Main.UInt32
            return value_data_size
        end
        if s == :data
            offset = Main.getfield(m, :address)
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            value_name_len = Main.jlread(io, Main.UInt16)::Main.UInt16
            offset += Main.sizeof(Main.UInt16)
            offset += Main.name_len
            Main.seek(io, offset)
            value_data_size = Main.jlread(io, Main.UInt32)::Main.UInt32
            offset += Main.sizeof(Main.UInt32)
            Main.seek(io, offset)
            value_data = Main.jlread(io, Main.UInt8, Main.data_size)::Main.Vector{Main.UInt8}
            return value_data
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end

================================================================================
NESTED CONDITIONS STRUCT EXPANSION
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestNested}, hflags, hsize, kw)
        default_version = 3
        version = Main.get(kw, :version, default_version)
        Main.jlwrite(fly, UInt8(version))
        if version == 3
            default_flags = 0
            flags = Main.get(kw, :flags, default_flags)
            Main.jlwrite(fly, UInt8(flags))
            isset(flags, 0) && begin
                    Main.haskey(kw, :extra) || Main.throw(Main.ArgumentError("Argument :extra is required"))
                    extra = kw.extra
                    Main.jlwrite(fly, UInt32(extra))
                end
        end
        if version == 2
            Main.haskey(kw, :old_flags) || Main.throw(Main.ArgumentError("Argument :old_flags is required"))
            old_flags = kw.old_flags
            Main.jlwrite(fly, UInt16(old_flags))
        end
    end
    function compute_size(::Main.Val{Main.TestNested}, hflags, hsize, kw)
        offset = 0
        default_version = 3
        version = Main.get(kw, :version, default_version)
        offset += Main.sizeof(UInt8)
        if version == 3
            default_flags = 0
            flags = Main.get(kw, :flags, default_flags)
            offset += Main.sizeof(UInt8)
            isset(flags, 0) && begin
                    Main.haskey(kw, :extra) || Main.throw(Main.ArgumentError("Argument :extra is required"))
                    extra = kw.extra
                    offset += Main.sizeof(UInt32)
                end
        end
        if version == 2
            Main.haskey(kw, :old_flags) || Main.throw(Main.ArgumentError("Argument :old_flags is required"))
            old_flags = kw.old_flags
            offset += Main.sizeof(UInt16)
        end
        return offset
    end
    function messageshow(::Main.Val{Main.TestNested}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :version => version)
        if version == 3
            flags = Main.jlread(io, UInt8)
            Main.push!(keyvalue, :flags => flags)
            isset(flags, 0) && begin
                    extra = Main.jlread(io, UInt32)
                    Main.push!(keyvalue, :extra => extra)
                end
        end
        if version == 2
            old_flags = Main.jlread(io, UInt16)
            Main.push!(keyvalue, :old_flags => old_flags)
        end
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestNested, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :version
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            return value_version
        end
        if s == :flags
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            offset += Main.sizeof(Main.UInt8)
            Main.seek(io, offset)
            if Main.version == 3
                value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
                return value_flags
            end
        end
        if s == :extra
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            offset += Main.sizeof(Main.UInt8)
            if Main.version == 3
                Main.seek(io, offset)
                value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
            end
            Main.version == 3 && (offset += Main.sizeof(Main.UInt8))
            Main.seek(io, offset)
            if Main.version == 3 && Main.isset(Main.flags, 0)
                value_extra = Main.jlread(io, Main.UInt32)::Main.UInt32
                return value_extra
            end
        end
        if s == :old_flags
            offset = Main.getfield(m, :address)
            Main.seek(io, offset)
            value_version = Main.jlread(io, Main.UInt8)::Main.UInt8
            offset += Main.sizeof(Main.UInt8)
            if Main.version == 3
                Main.seek(io, offset)
                value_flags = Main.jlread(io, Main.UInt8)::Main.UInt8
            end
            Main.version == 3 && (offset += Main.sizeof(Main.UInt8))
            (Main.version == 3 && Main.isset(Main.flags, 0)) && (offset += Main.sizeof(Main.UInt32))
            Main.seek(io, offset)
            if Main.version == 2
                value_old_flags = Main.jlread(io, Main.UInt16)::Main.UInt16
                return value_old_flags
            end
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end
