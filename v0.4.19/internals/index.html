<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals &amp; Design · Julia Data Format</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Julia Data Format</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Basics</a></li><li><a class="tocitem" href="../customserialization/">Custom Serialization</a></li><li><a class="tocitem" href="../compression/">Compression</a></li><li class="is-active"><a class="tocitem" href>Internals &amp; Design</a></li><li><a class="tocitem" href="../hdf5compat/">HDF5 Compatibility</a></li><li><a class="tocitem" href="../legacy/">Legacy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals &amp; Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals &amp; Design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIO/JLD2.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-and-Design"><a class="docs-heading-anchor" href="#Internal-and-Design">Internal &amp; Design</a><a id="Internal-and-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-and-Design" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JLD2.CustomSerialization" href="#JLD2.CustomSerialization"><code>JLD2.CustomSerialization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CustomSerialization{T,S}</code></pre><p>On-disk representation for data that is written as if it were of Julia type <code>T</code>, but is read as type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.GlobalHeap" href="#JLD2.GlobalHeap"><code>JLD2.GlobalHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalHeap</code></pre><p>Represents an HDF5 global heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.Group" href="#JLD2.Group"><code>JLD2.Group</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Group{T}</code></pre><p>JLD group object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.Group-Tuple{JLD2.JLDFile, AbstractString}" href="#JLD2.Group-Tuple{JLD2.JLDFile, AbstractString}"><code>JLD2.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Group(f::JLDFile, name::AbstractString)</code></pre><p>Construct an empty group named <code>name</code> at the top level of <code>JLDFile</code> <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.Group-Union{Tuple{T}, Tuple{JLD2.Group{T}, AbstractString}} where T" href="#JLD2.Group-Union{Tuple{T}, Tuple{JLD2.Group{T}, AbstractString}} where T"><code>JLD2.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Group(g::Group, name::AbstractString)</code></pre><p>Construct a group named <code>name</code> as a child of group <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.H5Datatype" href="#JLD2.H5Datatype"><code>JLD2.H5Datatype</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">H5Datatype</code></pre><p>Supertype of all HDF5 datatypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.IndirectPointer" href="#JLD2.IndirectPointer"><code>JLD2.IndirectPointer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndirectPointer</code></pre><p>When writing data, we may need to enlarge the memory mapping, which would invalidate any memory addresses arising from the old <code>mmap</code> pointer. <code>IndirectPointer</code> holds a pointer to the <code>startptr</code> field of an MmapIO, and the offset relative to that pointer. It defers computing a memory address until converted to a Ptr{T}, so the memory mapping can be enlarged and addresses will remain valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.InlineUnionEl" href="#JLD2.InlineUnionEl"><code>JLD2.InlineUnionEl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InlineUnionEl{T1,T2}(mask::UInt8, t1::T1, t2::T2)</code></pre><p>Custom serialization struct for two member isbits union fields e.g. in other structs or arrays. To indicate that t1 is relevant the mask takes the value <code>UInt8(0)</code> and for t2 <code>UInt8(255)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.JLDFile" href="#JLD2.JLDFile"><code>JLD2.JLDFile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLDFile{T&lt;:IO}</code></pre><p>JLD file object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.JLDWriteSession" href="#JLD2.JLDWriteSession"><code>JLD2.JLDWriteSession</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLDWriteSession{T}</code></pre><p>A JLDWriteSession keeps track of references to serialized objects. If <code>T</code> is a Dict, <code>h5offset</code> maps an object ID (returned by calling <code>objectid</code>) to th <code>RelOffset</code> of the written dataset. If it is <code>Union{}</code>, then references are not tracked, and objects referenced multiple times are written multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.ReadRepresentation" href="#JLD2.ReadRepresentation"><code>JLD2.ReadRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReadRepresentation{T,ODR}</code></pre><p>A type encoding both the Julia type <code>T</code> and the on-disk (HDF5) representation <code>ODR</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.RelOffset" href="#JLD2.RelOffset"><code>JLD2.RelOffset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelOffset</code></pre><p>Represents an HDF5 relative offset. This differs from a file offset (used elsewhere) in that it is relative to the superblock base address. In practice, this means that <code>FILE_HEADER_LENGTH</code>has been subtracted. <code>fileoffset</code> and <code>h5offset</code> convert between <code>RelOffsets</code> and file offsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.TypeMappingException" href="#JLD2.TypeMappingException"><code>JLD2.TypeMappingException</code></a> — <span class="docstring-category">Type</span></header><section><div><p>constructrr(f::JLDFile, T::DataType, dt::CompoundType, attrs::Vector{ReadAttribute},             hard_failure::Bool=false)</p><p>Constructs a ReadRepresentation for a given type. This is the generic method for all types not specially handled below.</p><p>If hard_failure is true, then throw a TypeMappingException instead of attempting reconstruction. This helps in cases where we can&#39;t know if reconstructed parametric types will have a matching memory layout without first inspecting the memory layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.behead-Tuple{UnionAll}" href="#JLD2.behead-Tuple{UnionAll}"><code>JLD2.behead</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">behead(T)</code></pre><p>Given a UnionAll type, recursively eliminates the <code>where</code> clauses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.construct_array-Union{Tuple{T}, Tuple{IO, Type{T}, Int64}} where T" href="#JLD2.construct_array-Union{Tuple{T}, Tuple{IO, Type{T}, Int64}} where T"><code>JLD2.construct_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_array{T}(io::IO, ::Type{T}, ndims::Int)</code></pre><p>Construct array by reading <code>ndims</code> dimensions from <code>io</code>. Assumes <code>io</code> has already been seeked to the correct position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.fileoffset-Tuple{JLD2.JLDFile, JLD2.RelOffset}" href="#JLD2.fileoffset-Tuple{JLD2.JLDFile, JLD2.RelOffset}"><code>JLD2.fileoffset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fileoffset(f::JLDFile, x::RelOffset)</code></pre><p>Converts an offset <code>x</code> relative to the superblock of file <code>f</code> to an absolute offset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.group_payload_size-Tuple{Any}" href="#JLD2.group_payload_size-Tuple{Any}"><code>JLD2.group_payload_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">group_payload_size(g)</code></pre><p>Returns the size of a group payload, including link info, group info, and link messages, but not the object header. Provides space after the last object message for a continuation message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.h5offset-Tuple{JLD2.JLDFile, Int64}" href="#JLD2.h5offset-Tuple{JLD2.JLDFile, Int64}"><code>JLD2.h5offset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">h5offset(f::JLDFile, x::RelOffset)</code></pre><p>Converts an absolute file offset <code>x</code> to an offset relative to the superblock of file <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}" href="#JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}"><code>JLD2.jld_finalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jld_finalizer(f::JLDFile)</code></pre><p>When a JLDFile is finalized, it is possible that the <code>MmapIO</code> has been munmapped, since Julia does not guarantee finalizer order. This means that the underlying file may be closed before we get a chance to write to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.jldopen" href="#JLD2.jldopen"><code>JLD2.jldopen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jldopen(fname::AbstractString, mode::AbstractString; iotype=MmapIO, compress=false)</code></pre><p>Opens a JLD2 file at path <code>fname</code>.</p><p><code>&quot;r&quot;</code>: Open for reading only, failing if no file exists <code>&quot;r+&quot;</code>: Open for reading and writing, failing if no file exists <code>&quot;w&quot;</code>/<code>&quot;w+&quot;</code>: Open for reading and writing, overwriting the file if it already exists <code>&quot;a&quot;</code>/<code>&quot;a+&quot;</code>: Open for reading and writing, creating a new file if none exists, but               preserving the existing file if one is present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.jldsave-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString, Any}, Tuple{AbstractString, Any, T}} where T&lt;:Union{Type{IOStream}, Type{JLD2.MmapIO}}" href="#JLD2.jldsave-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString, Any}, Tuple{AbstractString, Any, T}} where T&lt;:Union{Type{IOStream}, Type{JLD2.MmapIO}}"><code>JLD2.jldsave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jldsave(filename, compress=false; kwargs...)</code></pre><p>Creates a JLD2 file at <code>filename</code> and stores the variables given as keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-none">jldsave(&quot;example.jld2&quot;; a=1, b=2, c)</code></pre><p>is equivalent to</p><pre><code class="language-none">jldopen(&quot;example.jld2, &quot;w&quot;) do f
    f[&quot;a&quot;] = 1
    f[&quot;b&quot;] = 2
    f[&quot;c&quot;] = c
end</code></pre><p>To choose the io type <code>IOStream</code> instead of the default <code>MmapIO</code> use  <code>jldsave{IOStream}(fn; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.link_size-Tuple{String}" href="#JLD2.link_size-Tuple{String}"><code>JLD2.link_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">link_size(name::String)</code></pre><p>Returns the size of a link message, including message header.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.links_size-Tuple{Any}" href="#JLD2.links_size-Tuple{Any}"><code>JLD2.links_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">links_size(pairs)</code></pre><p>Returns the size of several link messages. <code>pairs</code> is an iterator of <code>String =&gt; RelOffset</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.load_datatypes-Tuple{JLD2.JLDFile}" href="#JLD2.load_datatypes-Tuple{JLD2.JLDFile}"><code>JLD2.load_datatypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_datatypes(f::JLDFile)</code></pre><p>Populate f.datatypes and f.jlh5types with all of the committed datatypes from a file. We need to do this before writing to make sure we reuse written datatypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.load_object-Tuple{Any}" href="#JLD2.load_object-Tuple{Any}"><code>JLD2.load_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_object(filename)</code></pre><p>Returns the only available object from the JLD2 file <code>filename</code> (The stored object name is inconsequential). If the file contains more than one or no objects, the function throws an <code>ArgumentError</code>.</p><p>For loading more than one object, use <a href="legacy/#JLD2.@load"><code>@load</code></a> macro, <a href="internals/#JLD2.jldopen"><code>jldopen</code></a> or the FileIO API.</p><p><strong>Example</strong></p><p>To load the only object from the JLD2 file example.jld2:</p><pre><code class="language-none">hello = &quot;world&quot;
save_object(&quot;example.jld2&quot;, hello)
hello_loaded = load_object(&quot;example.jld2&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.lookup_offset-Tuple{JLD2.Group, AbstractString}" href="#JLD2.lookup_offset-Tuple{JLD2.Group, AbstractString}"><code>JLD2.lookup_offset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lookup_offset(g::Group, name::AbstractString) -&gt; RelOffset</code></pre><p>Lookup the offset of a dataset in a group. Returns <code>UNDEFINED_ADDRESS</code> if the dataset is not present. Does not inspect <code>unwritten_child_groups</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.pathize-Tuple{JLD2.Group, AbstractString, Bool}" href="#JLD2.pathize-Tuple{JLD2.Group, AbstractString, Bool}"><code>JLD2.pathize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pathize(g::Group, name::AbstractString, create::Bool) -&gt; Tuple{Group,String}</code></pre><p>Converts a path to a group and name object. If <code>create</code> is true, any intermediate groups will be created, and the dataset name will be checked for uniqueness with existing names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.prewrite-Tuple{JLD2.JLDFile}" href="#JLD2.prewrite-Tuple{JLD2.JLDFile}"><code>JLD2.prewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prewrite(f::JLDFile)</code></pre><p>Check that a JLD file is actually writable, and throw an error if not. Sets the <code>written</code> flag on the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.printtoc-Tuple{JLD2.JLDFile}" href="#JLD2.printtoc-Tuple{JLD2.JLDFile}"><code>JLD2.printtoc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">printtoc([io::IO,] f::JLDFile [; numlines])</code></pre><p>Prints an overview of the contents of <code>f</code> to the <code>IO</code>.</p><p>Use the optional <code>numlines</code> parameter to restrict the amount of items listed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_array!" href="#JLD2.read_array!"><code>JLD2.read_array!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_array!(v::Array, f::JLDFile, rr)</code></pre><p>Fill the array <code>v</code> with the contents of JLDFile <code>f</code> at the current position, assuming a ReadRepresentation <code>rr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute, JLD2.H5Datatype, JLD2.ReadRepresentation}" href="#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute, JLD2.H5Datatype, JLD2.ReadRepresentation}"><code>JLD2.read_attr_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_attr_data(f::JLDFile, attr::ReadAttribute, expected_datatype::H5Datatype,
               rr::ReadRepresentation)</code></pre><p>jlread data from an attribute, assuming a specific HDF5 datatype and ReadRepresentation. If the HDF5 datatype does not match, throws an <code>UnsupportedFeatureException</code>. This allows better type stability while simultaneously validating the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute}" href="#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute}"><code>JLD2.read_attr_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_attr_data(f::JLDFile, attr::ReadAttribute)</code></pre><p>jlread data from an attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_compressed_array!" href="#JLD2.read_compressed_array!"><code>JLD2.read_compressed_array!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_compressed_array!(v::Array, f::JLDFile, rr, data_length::Int, ::Val{filter_id})</code></pre><p>Fill the array <code>v</code> with the compressed contents of JLDFile <code>f</code> at the current position, assuming a ReadRepresentation <code>rr</code> and that the compressed data has length <code>data_length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_data" href="#JLD2.read_data"><code>JLD2.read_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_data(f::JLDFile, dataspace::ReadDataspace, datatype_class::UInt8,
          datatype_offset::Int64, data_offset::Int64[, filter_id::UInt16,
          header_offset::RelOffset, attributes::Vector{ReadAttribute}])</code></pre><p>Read data from a file. If <code>datatype_class</code> is typemax(UInt8), the datatype is assumed to be committed, and <code>datatype_offset</code> points to the offset of the committed datatype&#39;s header. Otherwise, datatype_offset points to the offset of the datatype attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_scalar" href="#JLD2.read_scalar"><code>JLD2.read_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_scalar(f::JLDFile, rr, header_offset::RelOffset)</code></pre><p>Read raw data representing a scalar with read representation <code>rr</code> from the current position of JLDFile <code>f</code>. <code>header_offset</code> is the RelOffset of the object header, used to resolve cycles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_size-Tuple{IO, UInt8}" href="#JLD2.read_size-Tuple{IO, UInt8}"><code>JLD2.read_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_size(io::IO, flags::UInt8)</code></pre><p>Loads a variable-length size according to flags Expects that the first two bits of flags mean: 0   The size of the Length of Link Name field is 1 byte. 1   The size of the Length of Link Name field is 2 bytes. 2   The size of the Length of Link Name field is 4 bytes. 3   The size of the Length of Link Name field is 8 bytes. Returns the size as an Int</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.save_group-Tuple{JLD2.Group}" href="#JLD2.save_group-Tuple{JLD2.Group}"><code>JLD2.save_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_group(g::Group) -&gt; RelOffset</code></pre><p>Stores a group to a file, updating it if it has already been saved. Returns UNDEFINED_ADDRESS if the group was already stored, or the offset of the new group otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.save_object-Tuple{Any, Any}" href="#JLD2.save_object-Tuple{Any, Any}"><code>JLD2.save_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_object(filename, x)</code></pre><p>Stores an object <code>x</code> in a new JLD2 file at <code>filename</code>. If a file exists at this path, it will be overwritten.</p><p>Since the JLD2 format requires that all objects have a name, the object will be stored as <code>single_sotred_object</code>. If you want to store more than one object, use <a href="legacy/#JLD2.@save"><code>@save</code></a> macro, <a href="internals/#JLD2.jldopen"><code>jldopen</code></a> or the FileIO API.</p><p><strong>Example</strong></p><p>To save the string <code>hello</code> to the JLD2 file example.jld2:</p><pre><code class="language-none">hello = &quot;world&quot;
save_object(&quot;example.jld2&quot;, hello)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.symbol_length-Tuple{Symbol}" href="#JLD2.symbol_length-Tuple{Symbol}"><code>JLD2.symbol_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbol_length(x::Symbol)</code></pre><p>Returns the length of the string represented by <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.write_link-Tuple{Any, Any, Any}" href="#JLD2.write_link-Tuple{Any, Any, Any}"><code>JLD2.write_link</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_link(cio, name, offset)</code></pre><p>Write a link message at current position in <code>cio</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.@load-Tuple{Any, Vararg{Any}}" href="#JLD2.@load-Tuple{Any, Vararg{Any}}"><code>JLD2.@load</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@load filename var1 [var2 ...]</code></pre><p>Load one or more variables <code>var1,...</code> from JLD2 file <code>filename</code> into the current scope and return a vector of the loaded variable names.</p><p>For interactive use, the form <code>@load &quot;somefile.jld2&quot;</code> will load all variables from <code>&quot;somefile.jld2&quot;</code> into the current scope. This form only supports literal file names and should be avoided in more permanent code so that it&#39;s clear where the variables come from.</p><p><strong>Example</strong></p><p>To load the variables <code>hello</code> and <code>foo</code> from the file example.jld2, use</p><pre><code class="language-none">@load &quot;example.jld2&quot; hello foo</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.@save-Tuple{Any, Vararg{Any}}" href="#JLD2.@save-Tuple{Any, Vararg{Any}}"><code>JLD2.@save</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@save filename var1 [var2 ...]
@save filename {compress=true} var1 name2=var2</code></pre><p>Write one or more variables <code>var1,...</code> from the current scope to a JLD2 file <code>filename</code>.</p><p>For interactive use you can save all variables in the current module&#39;s global scope using <code>@save filename</code>. More permanent code should prefer the explicit form to avoid saving unwanted variables.</p><p><strong>Example</strong></p><p>To save the string <code>hello</code> and array <code>xs</code> to the JLD2 file example.jld2:</p><pre><code class="language-none">hello = &quot;world&quot;
xs = [1,2,3]
@save &quot;example.jld2&quot; hello xs</code></pre><p>For passing options to the saving command use {}</p><pre><code class="language-none">@save &quot;example.jld2&quot; {compress=true} hello xs</code></pre><p>For saving variables under a different name use regular assignment syntax</p><pre><code class="language-none">@save &quot;example.jld2&quot; greeting=hello xarray = xs</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compression/">« Compression</a><a class="docs-footer-nextpage" href="../hdf5compat/">HDF5 Compatibility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 27 January 2022 15:27">Thursday 27 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
