var documenterSearchIndex = {"docs":
[{"location":"legacy/#Legacy","page":"Legacy","title":"Legacy","text":"","category":"section"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"This page lists features of JLD2 that are kept for legacy purposes. In particular, the following sections describes the @load and @save macros. They have been the default for many users but they unnecessarily introduce new macro-based syntax. Over time a range of issues have been opened by new users struggling with them. Since their inception, the julia language  has improved significantly and macros may no longer be necessary in this case.","category":"page"},{"location":"legacy/#@save-and-@load-macros","page":"Legacy","title":"@save and @load macros","text":"","category":"section"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"The @save and @load macros are the simplest way to interact with a JLD2 file. The @save macro writes one or more variables from the current scope to the JLD2 file. For example:","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"using JLD2\nhello = \"world\"\nfoo = :bar\n@save \"example.jld2\" hello foo","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"This writes the variables hello and foo to datasets in a new JLD2 file named example.jld2. The @load macro loads variables out of a JLD2 file:","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"@load \"example.jld2\" hello foo","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"This assigns the contents of the hello and foo datasets to variables of the same name in the current scope.","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"It is best practice to explicitly name the variables to be loaded and saved from a file, so that it is clear from whence these variables arise. However, for convenience, JLD2 also provides variants of @load and @save that do not require variables to be named explicitly. When called with no variable arguments, @save <filename> writes all variables in the global scope of the current module to file <filename>, while @load <filename> loads all variables in file <filename>. When called with no variable arguments, @load requires that the file name is provided as a string literal, i.e., it is not possible to select the file at runtime.","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"Additional customization is possible using assignment syntax and option passing:","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"@save \"example.jld2\" bye=hello bar=foo\n@save \"example.jld2\" {compress=true} hello bar=foo","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"@save\n@load","category":"page"},{"location":"legacy/#JLD2.@save","page":"Legacy","title":"JLD2.@save","text":"@save filename var1 [var2 ...]\n@save filename {compress=true} var1 name2=var2\n\nWrite one or more variables var1,... from the current scope to a JLD2 file filename.\n\nFor interactive use you can save all variables in the current module's global scope using @save filename. More permanent code should prefer the explicit form to avoid saving unwanted variables.\n\nExample\n\nTo save the string hello and array xs to the JLD2 file example.jld2:\n\nhello = \"world\"\nxs = [1,2,3]\n@save \"example.jld2\" hello xs\n\nFor passing options to the saving command use {}\n\n@save \"example.jld2\" {compress=true} hello xs\n\nFor saving variables under a different name use regular assignment syntax\n\n@save \"example.jld2\" greeting=hello xarray = xs\n\n\n\n\n\n","category":"macro"},{"location":"legacy/#JLD2.@load","page":"Legacy","title":"JLD2.@load","text":"@load filename var1 [var2 ...]\n\nLoad one or more variables var1,... from JLD2 file filename into the current scope and return a vector of the loaded variable names.\n\nFor interactive use, the form @load \"somefile.jld2\" will load all variables from \"somefile.jld2\" into the current scope. This form only supports literal file names and should be avoided in more permanent code so that it's clear where the variables come from.\n\nExample\n\nTo load the variables hello and foo from the file example.jld2, use\n\n@load \"example.jld2\" hello foo\n\n\n\n\n\n","category":"macro"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/#Explicit-Type-Remapping","page":"Advanced Usage","title":"Explicit Type Remapping","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Sometimes you store data using structs that you defined yourself or are shipped with some package and weeks later, when you want to  load the data, the structs have changed.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2\nstruct A\n    x::Int\nend\njldsave(\"example.jld2\"; a = A(42))","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"This results in warnings and sometimes even errors when trying to load the file as demonstrated here.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"julia> using JLD2\njulia> struct A{T}\n            x::T\n       end\njulia> load(\"example.jld2\")\nâ”Œ Warning: read type A is not a leaf type in workspace; reconstructing\nâ”” @ JLD2 ~/.julia/dev/JLD2/src/data/reconstructing_datatypes.jl:273\nDict{String, Any} with 1 entry:\n  \"a\" => var\"##A#257\"(42)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"As of JLD2 version v0.4.21 there is a fix. The JLDFile struct contains a typemap dictionary that allows for explicit type remapping.  Now you can define a struct that matches the old definition and load your data.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"julia> struct A_old\n            x::Int\n        end\njulia> f = jldopen(\"example.jld2\",\"r\"; typemap=Dict(\"Main.A\" => A_old))\nJLDFile /home/jonas/.julia/dev/JLD2/example.jld2 (read-only)\n â””â”€ðŸ”¢ a\njulia> f[\"a\"]\nA_old(42)","category":"page"},{"location":"advanced/#Upgrading-old-structures-on-load","page":"Advanced Usage","title":"Upgrading old structures on load","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The section above explains how you can make JLD2 load old structs with a different DataType name as target. A different method for loading old data is described here:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"# This is the old version of the struct stored in the file\nstruct OldStructVersion\n    x::Int\n    y::Float64\nend\norig = OldStructVersion(1,2.0)\njldsave(\"test.jld2\"; data=orig)\n\n### new session\n\n# This is the new version of your struct\nstruct UpdatedStruct\n    x::Float64 # no longer int\n    y::Float64\n    z::Float64 # = x*y\nend\n\n# When upgrading a struct, JLD2 will load the fields of the old struct into a `NamedTuple`\n# and call `rconvert` on it. Here we implement a conversion method that returns an `UpdatedStruct`\nJLD2.rconvert(::Type{UpdatedStruct}, nt::NamedTuple) = UpdatedStruct(Float64(nt.x), nt.y, nt.x*nt.y)\n\n# Here we provide the `typemap` keyword argument. It is a dictionary mapping the stored struct name\n# to an `Upgrade` instance with the new struct.\nload(\"test.jld2\", \"data\"; typemap=Dict(\"Main.OldStructVersion\" => JLD2.Upgrade(UpdatedStruct)))","category":"page"},{"location":"advanced/#Groups-Appending-to-files","page":"Advanced Usage","title":"Groups - Appending to files","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Group objects can be constructed with two optional keyword arguments:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"g = Group(file;\n          est_num_entries=4\n          est_link_name_len=8)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"These determine how much (additional) empty space should be allocated for the group description. (list of entries) This can be useful for performance when one expects to append many additional datasets after first writing the file.","category":"page"},{"location":"advanced/#JLD2DebugTools","page":"Advanced Usage","title":"JLD2DebugTools","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"There is an experimental repository JLD2DebugTools.jl that may help with debugging files.","category":"page"},{"location":"advanced/#Fallback-Behaviour","page":"Advanced Usage","title":"Fallback Behaviour","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"By default JLD2 will attempt to open files using the MmapIO backend. If that fails, it retries using IOStream.","category":"page"},{"location":"customserialization/#Custom-Serialization","page":"Custom Serialization","title":"Custom Serialization","text":"","category":"section"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"The API is simple enough, to enable custom serialization for your type A you define a new type e.g. ASerialization that contains the fields you want to store and define JLD2.writeas(::Type{A}) = ASerialization. Internally JLD2 will call Base.convert when writing and loading, so you need to make sure to extend that for your type.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"struct A\n    x::Int\nend\n\nstruct ASerialization\n    x::Vector{Int}\nend\n\nJLD2.writeas(::Type{A}) = ASerialization\nBase.convert(::Type{ASerialization}, a::A) = ASerialization([a.x])\nBase.convert(::Type{A}, a::ASerialization) = A(only(a.x))","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"warning: Already defined custom serialization\nTake care, some Julia internal types already use a CustomSerialization and JLD2.jl cannot nest them. In order to avoid unexpected behavior you should define a wrapper type, such as in the example above ASerialization even if you could use a simple Julia built in type (as in this case Vector{Int}). Target types to avoid are <: AbstractDict and <:Array.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"If you do not want to overload Base.convert then you can also define","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"JLD2.wconvert(::Type{ASerialization}, a::A) = ASerialization([a.x])\nJLD2.rconvert(::Type{A}, a::ASerialization) = A(only(a.x))","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"instead. This may be particularly relevant when types are involved that are not your own.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"struct B\n    x::Float64\nend\n\nJLD2.writeas(::Type{B}) = Float64\nJLD2.wconvert(::Type{Float64}, b::B) = b.x\nJLD2.rconvert(::Type{B}, x::Float64) = B(x)\n\narr = [B(rand()) for i=1:10]\n\n@save \"test.jld2\" arr","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"In this example JLD2 converts the array of B structs to a plain Vector{Float64} prior to  storing to disk.","category":"page"},{"location":"hdf5compat/#HDF5-Compatibility","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"JLD2 is built upon the HDF5 Format Specification and produces files that are compatible with the official HDF5 C library.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"This has the advantage that other libraries that use HDF5 such as the Julia wrapper HDF5.jl or  even with h5py using Python. In addition to that, adhering to the HDF5 standards allows you to use the file introspection tools  such as h5dump and h5debug provided by the HDF5 group.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"warning: Warning\nGeneral compatibility only holds for a list of basic types:     - Numbers FloatXX, IntXX and UIntXX     - Strings     - Arrays of those types Other structures can in principle also be decoded but may involve work.  See below for more information","category":"page"},{"location":"hdf5compat/#Understanding-how-Julia-structs-are-encoded","page":"HDF5 Compatibility","title":"Understanding how Julia structs are encoded","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"The HDF5 standard supports so-called compound datatypes that comprise of a set of  already known datatypes. This is very similar to julia's structs.  When a user wants to write a non-default type to disk then JLD2 will create the corresponding compound datatypes and commit them to the file. All custom type definitions in a JLD2 file will be stored  in a _types/ group. This way, the type definitions only needs to be written to the file once and all instances of that struct reference it.","category":"page"},{"location":"hdf5compat/#Example","page":"HDF5 Compatibility","title":"Example","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"julia> using JLD2\n\njulia> struct MyCustomStruct\n       x::Int64\n       y::Float64\n       end\n\njulia> @save \"test.jld2\" a=MyCustomStruct(42, Ï€)","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"Let's see what JLD2 makes out of my simple MyCustomStruct. To do that we view the output of h5dump","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"$> h5dump test.jld2\nHDF5 \"test.jld2\" {\nGROUP \"/\" {\n   GROUP \"_types\" {\n      DATATYPE \"00000001\" H5T_COMPOUND {\n         H5T_STRING {\n            STRSIZE H5T_VARIABLE;\n            STRPAD H5T_STR_NULLPAD;\n            CSET H5T_CSET_UTF8;\n            CTYPE H5T_C_S1;\n         } \"name\";\n         H5T_VLEN { H5T_REFERENCE { H5T_STD_REF_OBJECT }} \"parameters\";\n      }\n         ATTRIBUTE \"julia_type\" {\n            DATATYPE  \"/_types/00000001\"\n            DATASPACE  SCALAR\n            DATA {\n            (0): {\n                  \"Core.DataType\",\n                  ()\n               }\n            }\n         }\n      DATATYPE \"00000002\" H5T_COMPOUND {\n         H5T_STD_I64LE \"x\";\n         H5T_IEEE_F64LE \"y\";\n      }\n         ATTRIBUTE \"julia_type\" {\n            DATATYPE  \"/_types/00000001\"\n            DATASPACE  SCALAR\n            DATA {\n            (0): {\n                  \"Main.MyCustomStruct\",\n                  ()\n               }\n            }\n         }\n   }\n   DATASET \"a\" {\n      DATATYPE  \"/_types/00000002\"\n      DATASPACE  SCALAR\n      DATA {\n      (0): {\n            42,\n            3.14159\n         }\n      }\n   }\n}\n}","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"We can see that the file contains two things at top-level. There is a dataset \"a\" (that is what we wanted to store) and there is a group _types which is where all the necessary type information is stored.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"You can see that JLD2 committed two compound datatypes. The first one is Core.Datatype which at first seems rather unintuitive. It is needed to tell HDF5 what a serialized  julia datatype looks like (a name and a list of parameters).","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"Below that is the definition of MyCustomStruct with two fields  H5T_STD_I64LE \"x\" and H5T_IEEE_F64LE \"y\" defining the integer field x and the float field y.","category":"page"},{"location":"hdf5compat/#A-note-on-pointers","page":"HDF5 Compatibility","title":"A note on pointers","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"In the julia programming language pointers Ptr are not needed very often. However, when binary dependencies come into play and memory is passed back and forth, pointers do become relevant. Pointers are addresses to locations in memory and thus lose their meaning after a program has terminated.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"In principle, there is little point in storing a pointer to a file but in order to allow for a more seamless experience JLD2 will, similar to Base.Serialization silently accept pointers. This is useful when storing large structures such as a DifferentialEquations.jl solution object that might contain a pointer somewhere. Upon deserialization any pointer fields are instantiated as null pointers.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"This is done with just three lines of code utilizing the custom serialization logic and  it is shown here as it serves as a good example for usage of that feature.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"   writeas(::Type{<:Ptr}) = Nothing\n   rconvert(::Type{Ptr{T}}, ::Nothing) where {T} = Ptr{T}()","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"Usually one would also have to define a method for wconvert. However, in this  case JLD2 figures out that no explicit conversion is needed to construct nothing.","category":"page"},{"location":"#Julia-Data-Format-JLD2","page":"Basics","title":"Julia Data Format - JLD2","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"JLD2 saves and loads Julia data structures in a format comprising a subset of HDF5, without any dependency on the HDF5 C library.  JLD2 is able to read most HDF5 files created by other HDF5 implementations supporting HDF5 File Format Specification Version 3.0 (i.e. libhdf5 1.10 or later) and similarly those should be able to read the files that JLD2 produces. JLD2 provides read-only support for files created with the JLD package.","category":"page"},{"location":"#Reading-and-writing-data","page":"Basics","title":"Reading and writing data","text":"","category":"section"},{"location":"#A-new-interface:-jldsave","page":"Basics","title":"A new interface: jldsave","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"jldsave makes use of julia's keyword argument syntax to store files, thus leveraging the parser and not having to rely on macros. To use it, write","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"x = 1\ny = 2\nz = 42\n\n# The simplest case:\njldsave(\"example.jld2\"; x, y, z)\n# it is equivalent to \njldsave(\"example.jld2\"; x=x, y=y, z=z)\n\n# You can assign new names selectively\njldsave(\"example.jld2\"; x, a=y, z)\n\n# and if you want to confuse your future self and everyone else, do\njldsave(\"example.jld2\"; z=x, x=y, y=z)","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Compression and non-default IO types may be set via positional arguments.","category":"page"},{"location":"#save_object-and-load_object-functions","page":"Basics","title":"save_object and load_object functions","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"If only a single object needs to stored and loaded from a file, one can use save_object and load_object functions.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"save_object\nload_object","category":"page"},{"location":"#JLD2.save_object","page":"Basics","title":"JLD2.save_object","text":"save_object(filename, x)\n\nStores an object x in a new JLD2 file at filename. If a file exists at this path, it will be overwritten.\n\nSince the JLD2 format requires that all objects have a name, the object will be stored as single_stored_object. If you want to store more than one object, use @save macro, jldopen or the FileIO API.\n\nExample\n\nTo save the string hello to the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\n\n\n\n\n\n","category":"function"},{"location":"#JLD2.load_object","page":"Basics","title":"JLD2.load_object","text":"load_object(filename)\n\nReturns the only available object from the JLD2 file filename (The stored object name is inconsequential). If the file contains more than one or no objects, the function throws an ArgumentError.\n\nFor loading more than one object, use @load macro, jldopen or the FileIO API.\n\nExample\n\nTo load the only object from the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\nhello_loaded = load_object(\"example.jld2\")\n\n\n\n\n\n","category":"function"},{"location":"#save-and-load-functions","page":"Basics","title":"save and load functions","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"The save and load functions, provided by FileIO, provide a mechanism to read and write data from a JLD2 file. To use these functions, you may either write using FileIO or using JLD2. FileIO will determine the correct package automatically.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"The save function accepts an AbstractDict yielding the key/value pairs, where the key is a string representing the name of the dataset and the value represents its contents:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"using FileIO\nsave(\"example.jld2\", Dict(\"hello\" => \"world\", \"foo\" => :bar))","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"The save function can also accept the dataset names and contents as arguments:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"save(\"example.jld2\", \"hello\", \"world\", \"foo\", :bar)","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"When using the save function, the file extension must be .jld2, since the extension .jld currently belongs to the previous JLD package.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"If called with a filename argument only, the load function loads all datasets from the given file into a Dict:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"load(\"example.jld2\") # -> Dict{String,Any}(\"hello\" => \"world\", \"foo\" => :bar)","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"If called with a single dataset name, load returns the contents of that dataset from the file:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"load(\"example.jld2\", \"hello\") # -> \"world\"","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"If called with multiple dataset names, load returns the contents of the given datasets as a tuple:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"load(\"example.jld2\", \"hello\", \"foo\") # -> (\"world\", :bar)","category":"page"},{"location":"#File-interface","page":"Basics","title":"File interface","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"It is also possible to interact with JLD2 files using a file-like interface. The jldopen function accepts a file name and an argument specifying how the file should be opened:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"using JLD2\n\nf = jldopen(\"example.jld2\", \"r\")  # open read-only (default)\nf = jldopen(\"example.jld2\", \"r+\") # open read/write, failing if no file exists\nf = jldopen(\"example.jld2\", \"w\")  # open read/write, overwriting existing file\nf = jldopen(\"example.jld2\", \"a+\") # open read/write, preserving contents of existing file or creating a new file","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Data can be written to the file using write(f, \"name\", data) or f[\"name\"] = data, or read from the file using read(f, \"name\") or f[\"name\"]. When you are done with the file, remember to call close(f).","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Like open, jldopen also accepts a function as the first argument, permitting do-block syntax:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"jldopen(\"example.jld2\", \"w\") do file\n    file[\"bigdata\"] = randn(5)\nend","category":"page"},{"location":"#Groups","page":"Basics","title":"Groups","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"It is possible to construct groups within a JLD2 file, which may or may not be useful for organizing your data. You can create groups explicitly:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"jldopen(\"example.jld2\", \"w\") do file\n    mygroup = JLD2.Group(file, \"mygroup\")\n    mygroup[\"mystuff\"] = 42\nend","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"or implicitly, by saving a variable with a name containing slashes as path delimiters:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"jldopen(\"example.jld2\", \"w\") do file\n    file[\"mygroup/mystuff\"] = 42\nend\n# or save(\"example.jld2\", \"mygroup/mystuff\", 42)","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Both of these examples yield the same group structure, which you can see at the REPL:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> file = jldopen(\"example.jld2\", \"r\")\nJLDFile /Users/simon/example.jld2 (read-only)\n â””â”€ðŸ“‚ mygroup\n    â””â”€ðŸ”¢ mystuff","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Similarly, you can access groups directly:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"jldopen(\"example.jld2\", \"r\") do file\n    @assert file[\"mygroup\"][\"mystuff\"] == 42\nend","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"or using slashes as path delimiters:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"@assert load(\"example.jld2\", \"mygroup/mystuff\") == 42","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"When loading files with nested groups these will be unrolled into paths by default but yield nested dictionaries but with the nested keyword argument.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"load(\"example.jld2\") # -> Dict(\"mygroup/mystuff\" => 42)\nload(\"example.jld2\"; nested=true) # -> Dict(\"mygroup\" => Dict(\"mystuff\" => 42))","category":"page"},{"location":"#Unpack.jl-API","page":"Basics","title":"Unpack.jl API","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"When additionally loading the UnPack.jl package, its @unpack and @pack! macros can be used to quickly save and load data from the file-like interface. Example:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"using UnPack\nfile = jldopen(\"example.jld2\", \"w\")\nx, y = rand(2)\n\n@pack! file = x, y # equivalent to file[\"x\"] = x; file[\"y\"] = y\n@unpack x, y = file # equivalent to x = file[\"x\"]; y = file[\"y\"]","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"The group file_group = Group(file, \"mygroup\") can be accessed with the same file-like interface as the \"full\" struct.","category":"page"},{"location":"#Gotchas","page":"Basics","title":"Gotchas","text":"","category":"section"},{"location":"#Objects-are-cached-during-loading","page":"Basics","title":"Objects are cached during loading","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"JLD2 caches objects during loading. It may give you the same object twice. This can lead to surprising results if you edit loaded arrays. Note, the underlying file is not being edited!","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> jldsave(\"demo.jld2\", a=zeros(2))\n\njulia> f = jldopen(\"demo.jld2\")\nJLDFile /home/isensee/demo.jld2 (read-only)\n â””â”€ðŸ”¢ a\n\njulia> a = f[\"a\"] # bind loaded array to name `a`\n2-element Vector{Float64}:\n 0.0\n 0.0\n\njulia> a[1] = 42; # editing the underlying array\n\njulia> f[\"a\"]\n2-element Vector{Float64}:\n 42.0\n  0.0\n\njulia> a=nothing # remove all references to the loaded array\n\njulia> GC.gc(true) # call GC to remove the cache\n\njulia> f[\"a\"] # a new copy is loaded from the file\n2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"#Cross-compatibility","page":"Basics","title":"Cross-compatibility","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"JLD2 tries to write files in a way that allows you to load them on different operating systems and in particular both on 32bit and 64bit systems. However, many julia structs may be inherently different on different architectures making this task impossible. In particular, moving data from a 64bit system to a 32bit system is only guaranteed to work for basic datatypes.","category":"page"},{"location":"#Security","page":"Basics","title":"Security","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Beware of opening JLD2 files from untrusted sources. A malicious file may execute code on your computer. See e.g. here. To check a file, you can use JLD2DebugTools.jl to view what kinds of objects are stored.","category":"page"},{"location":"compression/#Compression","page":"Compression","title":"Compression","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"JLD2 supports compression of isbits arrays. This includes the typical Array{Float64} but also arrays of custom structs that are immutable and only consist of basic number type fields.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"To enable the default compression, you can write","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"FileIO.save(\"example.jld2\", \"large_array\", zeros(10000); compress = true)","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using the FileIO API. Alternatively use","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"jldsave(\"example.jld2\", true; large_array=zeros(10000))","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"or","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"jldopen(\"example.jld2\", \"w\"; compress = true) do f\n    f[\"large_array\"] = zeros(10000)\nend","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"When reading a file JLD2 detects compression and automatically decompresses the data so it is not necessary to pass any extra parameters for that case.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"JLD2 uses TranscodingStreams.jl to interact with compression algorithms. Compression is disabled by default and if compress = true is passed,  CodecZlib.jl will be used.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"note: Note\nNote that CodecZlib.jl must be explicitly installed for compression/decompression to work. If the package is not already loaded JLD2 will try to dynamically load it, but it is recommended to do it explicitly, e.g. using JLD2, CodecZlib.","category":"page"},{"location":"compression/#Choosing-a-compression-algorithm","page":"Compression","title":"Choosing a compression algorithm","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"If you want to use a different compression algorithm that is better suited to your needs, you can also directly pass a compressor.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Library Compressor \nCodecZlib.jl ZlibCompressor The default as it is very widely used.\nCodecBzip2.jl Bzip2Compressor Can often times be faster\nCodecLz4.jl LZ4FrameCompressor Fast, but not compatible to the LZ4 shipped by HDF5","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"To use any of these, replace the compress = true argument with an instance of the compressor, e.g.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2, CodecBzip2\njldopen(\"example.jld2\", \"w\"; compress = Bzip2Compressor()) do f\n    f[\"large_array\"] = zeros(10000)\nend","category":"page"},{"location":"compression/#Manually-selecting-compression-for-datasets","page":"Compression","title":"Manually selecting compression for datasets","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"Sometimes you may know, that some of your arrays are easily compressible and that for others it is not worth the effort. For precise control, the write function takes an optional keyword argument to override the file compression settings.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2\njldopen(\"example.jld2\", \"w\") do f\n    # This can be efficiently compressed  â†’ use compression\n    write(f, \"compressed_array\", zeros(10000); compress=true)\n\n    # Don't compress this \n    write(f, \"large_array\", rand(10000))\nend","category":"page"},{"location":"internals/#Internals-and-Design","page":"Internals & Design","title":"Internals & Design","text":"","category":"section"},{"location":"internals/#File-Interface","page":"Internals & Design","title":"File Interface","text":"","category":"section"},{"location":"internals/","page":"Internals & Design","title":"Internals & Design","text":"The JLDFile object mimics the API of Base.Dict as much as it can. In particular, keys, length, haskey, isempty, get, get! should work as expected.","category":"page"},{"location":"internals/","page":"Internals & Design","title":"Internals & Design","text":"Modules = [JLD2]","category":"page"},{"location":"internals/#JLD2.CommittedDatatype","page":"Internals & Design","title":"JLD2.CommittedDatatype","text":"CommittedDatatype\n\nReference to a shared datatype message (stored elsewhere in a file). These are stored in the _types group and indexed.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.CustomSerialization","page":"Internals & Design","title":"JLD2.CustomSerialization","text":"CustomSerialization{T,S}\n\nOn-disk representation for data that is written as if it were of Julia type T, but is read as type S.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.GlobalHeap","page":"Internals & Design","title":"JLD2.GlobalHeap","text":"GlobalHeap\n\nRepresents an HDF5 global heap structure.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Group","page":"Internals & Design","title":"JLD2.Group","text":"Group(file)\n\nJLD2 group object.\n\nAdvanced Usage\n\nTakes two optional keyword arguments:     estnumentries::Int=4     estlinkname_len::Int=8 These determine how much (additional) empty space should be allocated for the group description. (list of entries) This can be useful for performance when one expects to append many additional datasets after first writing the file.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Group-Tuple{JLD2.JLDFile, AbstractString}","page":"Internals & Design","title":"JLD2.Group","text":"Group(f::JLDFile, name::AbstractString)\n\nConstruct an empty group named name at the top level of JLDFile f.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.Group-Union{Tuple{T}, Tuple{JLD2.Group{T}, AbstractString}} where T","page":"Internals & Design","title":"JLD2.Group","text":"Group(g::Group, name::AbstractString)\n\nConstruct a group named name as a child of group g.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.H5Datatype","page":"Internals & Design","title":"JLD2.H5Datatype","text":"H5Datatype\n\nSupertype of all HDF5 datatypes.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.IndirectPointer","page":"Internals & Design","title":"JLD2.IndirectPointer","text":"IndirectPointer\n\nWhen writing data, we may need to enlarge the memory mapping, which would invalidate any memory addresses arising from the old mmap pointer. IndirectPointer holds a pointer to the startptr field of an MmapIO, and the offset relative to that pointer. It defers computing a memory address until converted to a Ptr{T}, so the memory mapping can be enlarged and addresses will remain valid.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.InlineUnionEl","page":"Internals & Design","title":"JLD2.InlineUnionEl","text":"InlineUnionEl{T1,T2}(mask::UInt8, t1::T1, t2::T2)\n\nCustom serialization struct for two member isbits union fields e.g. in other structs or arrays. To indicate that t1 is relevant the mask takes the value UInt8(0) and for t2 UInt8(255)\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.JLDFile","page":"Internals & Design","title":"JLD2.JLDFile","text":"JLDFile{T<:IO}\n\nJLD file object.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.JLDWriteSession","page":"Internals & Design","title":"JLD2.JLDWriteSession","text":"JLDWriteSession{T}\n\nA JLDWriteSession keeps track of references to serialized objects. If T is a Dict, h5offset maps an object ID (returned by calling objectid) to th RelOffset of the written dataset. If it is Union{}, then references are not tracked, and objects referenced multiple times are written multiple times.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.ReadRepresentation","page":"Internals & Design","title":"JLD2.ReadRepresentation","text":"ReadRepresentation{T,ODR}\n\nA type encoding both the Julia type T and the on-disk (HDF5) representation ODR.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.RelOffset","page":"Internals & Design","title":"JLD2.RelOffset","text":"RelOffset\n\nRepresents an HDF5 relative offset. This differs from a file offset (used elsewhere) in that it is relative to the superblock base address. fileoffset and h5offset convert between RelOffsets and file offsets.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.SharedDatatype","page":"Internals & Design","title":"JLD2.SharedDatatype","text":"SharedDatatype\n\nReference to a shared datatype message (stored elsewhere in a file).\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.TypeMappingException","page":"Internals & Design","title":"JLD2.TypeMappingException","text":"constructrr(f::JLDFile, T::DataType, dt::CompoundType, attrs::Vector{ReadAttribute},             hard_failure::Bool=false)\n\nConstructs a ReadRepresentation for a given type. This is the generic method for all types not specially handled below.\n\nIf hard_failure is true, then throw a TypeMappingException instead of attempting reconstruction. This helps in cases where we can't know if reconstructed parametric types will have a matching memory layout without first inspecting the memory layout.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Upgrade","page":"Internals & Design","title":"JLD2.Upgrade","text":"Upgrade(T)\n\nSpecify an upgrade path for serialized structs using the typemapkeyword argument andrconvert`.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.behead-Tuple{UnionAll}","page":"Internals & Design","title":"JLD2.behead","text":"behead(T)\n\nGiven a UnionAll type, recursively eliminates the where clauses\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.construct_array-Union{Tuple{T}, Tuple{IO, Type{T}, Val{1}}} where T","page":"Internals & Design","title":"JLD2.construct_array","text":"construct_array{T}(io::IO, ::Type{T}, ::Val{ndims})\n\nConstruct array by reading ndims dimensions from io. Assumes io has already been seeked to the correct position.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.fileoffset-Tuple{JLD2.JLDFile, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.fileoffset","text":"fileoffset(f::JLDFile, x::RelOffset)\n\nConverts an offset x relative to the superblock of file f to an absolute offset.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.group_payload_size-Tuple{Any}","page":"Internals & Design","title":"JLD2.group_payload_size","text":"group_payload_size(g)\n\nReturns the size of a group payload, including link info, group info, and link messages, but not the object header. Provides space after the last object message for a continuation message.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.h5offset-Tuple{JLD2.JLDFile, Integer}","page":"Internals & Design","title":"JLD2.h5offset","text":"h5offset(f::JLDFile, x::Integer)\n\nConverts an absolute file offset x to an offset relative to the superblock of file f.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}","page":"Internals & Design","title":"JLD2.jld_finalizer","text":"jld_finalizer(f::JLDFile)\n\nWhen a JLDFile is finalized, it is possible that the MmapIO has been munmapped, since Julia does not guarantee finalizer order. This means that the underlying file may be closed before we get a chance to write to it.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.jldopen","page":"Internals & Design","title":"JLD2.jldopen","text":"jldopen(fname::AbstractString, mode::AbstractString; iotype=MmapIO, compress=false, typemap=Dict())\n\nOpens a JLD2 file at path fname.\n\n\"r\": Open for reading only, failing if no file exists \"r+\": Open for reading and writing, failing if no file exists \"w\"/\"w+\": Open for reading and writing, overwriting the file if it already exists \"a\"/\"a+\": Open for reading and writing, creating a new file if none exists, but               preserving the existing file if one is present\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.jldsave","page":"Internals & Design","title":"JLD2.jldsave","text":"jldsave(filename; kwargs...)\njldsave(filename, compress; kwargs...)\njldsave(filename, compress, iotype; kwargs...)\n\nCreates a JLD2 file at filename and stores the variables given as keyword arguments.\n\nExamples\n\njldsave(\"example.jld2\"; a=1, b=2, c)\n\nis equivalent to\n\njldopen(\"example.jld2, \"w\") do f\n    f[\"a\"] = 1\n    f[\"b\"] = 2\n    f[\"c\"] = c\nend\n\nTo choose the io type IOStream instead of the default MmapIO use  jldsave(fn, IOStream; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.link_size-Tuple{String}","page":"Internals & Design","title":"JLD2.link_size","text":"link_size(name::String)\n\nReturns the size of a link message, including message header.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.links_size-Tuple{Any}","page":"Internals & Design","title":"JLD2.links_size","text":"links_size(pairs)\n\nReturns the size of several link messages. pairs is an iterator of String => RelOffset pairs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_attributes-Tuple{JLD2.JLDFile, AbstractString}","page":"Internals & Design","title":"JLD2.load_attributes","text":"load_attributes(f::JLDFile, name::AbstractString)\nload_attributes(g::Group, name::AbstractString)\nload_attributes(f::JLDFile, offset::RelOffset)\n\nReturn a list of attributes attached to the dataset or group.    \n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_data_or_dict-Tuple{Union{JLD2.Group, JLD2.JLDFile}, AbstractString}","page":"Internals & Design","title":"JLD2.load_data_or_dict","text":"load_data_or_dict(g::Union{JLDFile,Group}, varname::AbstractString)\n\nReturn the value of key varname but if it represents a Group load the group as a nested dictionary.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_datatypes-Tuple{JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.load_datatypes","text":"load_datatypes(f::JLDFile)\n\nPopulate f.datatypes and f.jlh5types with all of the committed datatypes from a file. We need to do this before writing to make sure we reuse written datatypes.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_object-Tuple{Any}","page":"Internals & Design","title":"JLD2.load_object","text":"load_object(filename)\n\nReturns the only available object from the JLD2 file filename (The stored object name is inconsequential). If the file contains more than one or no objects, the function throws an ArgumentError.\n\nFor loading more than one object, use @load macro, jldopen or the FileIO API.\n\nExample\n\nTo load the only object from the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\nhello_loaded = load_object(\"example.jld2\")\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.loadnesteddict-Tuple{Union{JLD2.Group, JLD2.JLDFile}}","page":"Internals & Design","title":"JLD2.loadnesteddict","text":"loadnesteddict(g::Union{JLDFile, Group})\n\nReturn a dictionary with all data contained in group or file. Nested groups are loaded as nested dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.lookup_offset-Tuple{JLD2.Group, AbstractString}","page":"Internals & Design","title":"JLD2.lookup_offset","text":"lookup_offset(g::Group, name::AbstractString) -> RelOffset\n\nLookup the offset of a dataset in a group. Returns UNDEFINED_ADDRESS if the dataset is not present. Does not inspect unwritten_child_groups.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.pathize-Tuple{JLD2.Group, AbstractString, Bool}","page":"Internals & Design","title":"JLD2.pathize","text":"pathize(g::Group, name::AbstractString, create::Bool) -> Tuple{Group,String}\n\nConverts a path to a group and name object. If create is true, any intermediate groups will be created, and the dataset name will be checked for uniqueness with existing names.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.prewrite-Tuple{JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.prewrite","text":"prewrite(f::JLDFile)\n\nCheck that a JLD file is actually writable, and throw an error if not. Sets the written flag on the file.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.printtoc-Tuple{JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.printtoc","text":"printtoc([io::IO,] f::JLDFile [; numlines])\n\nPrints an overview of the contents of f to the IO.\n\nUse the optional numlines parameter to restrict the amount of items listed.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_array!","page":"Internals & Design","title":"JLD2.read_array!","text":"read_array!(v::Array, f::JLDFile, rr)\n\nFill the array v with the contents of JLDFile f at the current position, assuming a ReadRepresentation rr.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute, JLD2.H5Datatype, JLD2.ReadRepresentation}","page":"Internals & Design","title":"JLD2.read_attr_data","text":"read_attr_data(f::JLDFile, attr::ReadAttribute, expected_datatype::H5Datatype,\n               rr::ReadRepresentation)\n\njlread data from an attribute, assuming a specific HDF5 datatype and ReadRepresentation. If the HDF5 datatype does not match, throws an UnsupportedFeatureException. This allows better type stability while simultaneously validating the data.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute}","page":"Internals & Design","title":"JLD2.read_attr_data","text":"read_attr_data(f::JLDFile, attr::ReadAttribute)\n\njlread data from an attribute.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_attribute-Tuple{IO, JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.read_attribute","text":"read_attribute(io::IO, f::JLDFile)\n\nRead an attribute message at the current position of the io object. Supports attribute message version 1 and 2.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_compressed_array!","page":"Internals & Design","title":"JLD2.read_compressed_array!","text":"read_compressed_array!(v::Array, f::JLDFile, rr, data_length::Int, ::Val{filter_id})\n\nFill the array v with the compressed contents of JLDFile f at the current position, assuming a ReadRepresentation rr and that the compressed data has length data_length.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_data","page":"Internals & Design","title":"JLD2.read_data","text":"read_data(f::JLDFile, dataspace::ReadDataspace, datatype_class::UInt8,\n          datatype_offset::Int64, data_offset::Int64[, filters::FilterPipeline,\n          header_offset::RelOffset, attributes::Vector{ReadAttribute}])\n\nRead data from a file. If datatype_class is typemax(UInt8), the datatype is assumed to be committed, and datatype_offset points to the offset of the committed datatype's header. Otherwise, datatype_offset points to the offset of the datatype attribute.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_scalar","page":"Internals & Design","title":"JLD2.read_scalar","text":"read_scalar(f::JLDFile, rr, header_offset::RelOffset)\n\nRead raw data representing a scalar with read representation rr from the current position of JLDFile f. header_offset is the RelOffset of the object header, used to resolve cycles.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_size-Tuple{IO, UInt8}","page":"Internals & Design","title":"JLD2.read_size","text":"read_size(io::IO, flags::UInt8)\n\nLoads a variable-length size according to flags Expects that the first two bits of flags mean: 0   The size of the Length of Link Name field is 1 byte. 1   The size of the Length of Link Name field is 2 bytes. 2   The size of the Length of Link Name field is 4 bytes. 3   The size of the Length of Link Name field is 8 bytes. Returns the size as an Int\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.readas-Tuple{Any}","page":"Internals & Design","title":"JLD2.readas","text":"readas(::Type)::Type\n\nExperimental feature:  JLD2.readas can be overloaded to override which type a saved type is read as, and is used together with custom serialization using JLD2.writeas.\n\nThe typical case is custom serialization of parametric types, where not all type parameters are available during reading.  Consider the following example for an anonymous function fun inside a Foo\n\nstruct Foo{F<:Function}\n    fun::F\nend\nstruct FooSerialization\n    fun\nend\nJLD2.writeas(::Type{<:Foo}) = FooSerialization\nBase.convert(::Type{<:FooSerialization}, f::Foo) = FooSerialization(f.fun)\n\nJLD2.readas(::Type{<:FooSerialization}) = Foo\nstruct UndefinedFunction <:Function\n    fun\nend\n(f::UndefinedFunction)(args...; kwargs...) = error(\"The function $(f.fun) is not defined\")\nfunction Base.convert(::Type{<:Foo}, f::FooSerialization)\n    isa(f.fun, Function) && return Foo(f.fun)\n    return Foo(UndefinedFunction(f.fun))\nend\n\nIf we include these definitions, call jldsave(\"foo.jld2\"; foo=Foo(x->x^2)), restart julia, include the definitions again, and call foo = jldopen(\"foo.jld2\") do io; io[\"foo\"]; end, we get foo::Foo{UndefinedFunction} and foo::FooSerialization with and without defining the JLD2.readas above, respectively.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.save_group-Tuple{JLD2.Group}","page":"Internals & Design","title":"JLD2.save_group","text":"save_group(g::Group) -> RelOffset\n\nStores a group to a file, updating it if it has already been saved. Returns UNDEFINED_ADDRESS if the group was already stored, or the offset of the new group otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.save_object-Tuple{Any, Any}","page":"Internals & Design","title":"JLD2.save_object","text":"save_object(filename, x)\n\nStores an object x in a new JLD2 file at filename. If a file exists at this path, it will be overwritten.\n\nSince the JLD2 format requires that all objects have a name, the object will be stored as single_stored_object. If you want to store more than one object, use @save macro, jldopen or the FileIO API.\n\nExample\n\nTo save the string hello to the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.shorttypestring-Union{Tuple{Type{JLD2.UnknownType{T, P}}}, Tuple{P}, Tuple{T}} where {T, P}","page":"Internals & Design","title":"JLD2.shorttypestring","text":"shorttypestring(::Type{ <:UnknownType})\n\nConvert an UnknownType to a corresponding string. This is only used to create names for reconstructed types. See also typestring.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.skip_to_aligned!","page":"Internals & Design","title":"JLD2.skip_to_aligned!","text":"skip_to_aligned!(io, rel=0)\n\nSkip to nearest position aligned to a multiple of 8 bytes relative to rel.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.symbol_length-Tuple{Symbol}","page":"Internals & Design","title":"JLD2.symbol_length","text":"symbol_length(x::Symbol)\n\nReturns the length of the string represented by x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.typestring-Union{Tuple{Type{JLD2.UnknownType{T, P}}}, Tuple{P}, Tuple{T}} where {T, P}","page":"Internals & Design","title":"JLD2.typestring","text":"typestring(::Type{ <:UnknownType})\n\nConvert an UnknownType to a corresponding string. This is only used for warning during reconstruction errors. See also shorttypestring.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_link-Tuple{Any, Any, Any}","page":"Internals & Design","title":"JLD2.write_link","text":"write_link(cio, name, offset)\n\nWrite a link message at current position in cio.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.@load-Tuple{Any, Vararg{Any}}","page":"Internals & Design","title":"JLD2.@load","text":"@load filename var1 [var2 ...]\n\nLoad one or more variables var1,... from JLD2 file filename into the current scope and return a vector of the loaded variable names.\n\nFor interactive use, the form @load \"somefile.jld2\" will load all variables from \"somefile.jld2\" into the current scope. This form only supports literal file names and should be avoided in more permanent code so that it's clear where the variables come from.\n\nExample\n\nTo load the variables hello and foo from the file example.jld2, use\n\n@load \"example.jld2\" hello foo\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JLD2.@save-Tuple{Any, Vararg{Any}}","page":"Internals & Design","title":"JLD2.@save","text":"@save filename var1 [var2 ...]\n@save filename {compress=true} var1 name2=var2\n\nWrite one or more variables var1,... from the current scope to a JLD2 file filename.\n\nFor interactive use you can save all variables in the current module's global scope using @save filename. More permanent code should prefer the explicit form to avoid saving unwanted variables.\n\nExample\n\nTo save the string hello and array xs to the JLD2 file example.jld2:\n\nhello = \"world\"\nxs = [1,2,3]\n@save \"example.jld2\" hello xs\n\nFor passing options to the saving command use {}\n\n@save \"example.jld2\" {compress=true} hello xs\n\nFor saving variables under a different name use regular assignment syntax\n\n@save \"example.jld2\" greeting=hello xarray = xs\n\n\n\n\n\n","category":"macro"}]
}
