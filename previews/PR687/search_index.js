var documenterSearchIndex = {"docs":
[{"location":"legacy/#Legacy","page":"Legacy","title":"Legacy","text":"","category":"section"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"This page lists features of JLD2 that are kept for legacy purposes. In particular, the following sections describes the @load and @save macros. They have been the default for many users but they unnecessarily introduce new macro-based syntax. Over time a range of issues have been opened by new users struggling with them. Since their inception, the Julia language has improved significantly and macros may no longer be necessary in this case.","category":"page"},{"location":"legacy/#@save-and-@load-macros","page":"Legacy","title":"@save and @load macros","text":"","category":"section"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"The @save and @load macros are the simplest way to interact with a JLD2 file. The @save macro writes one or more variables from the current scope to the JLD2 file. For example:","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"using JLD2\nhello = \"world\"\nfoo = :bar\n@save \"example.jld2\" hello foo","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"This writes the variables hello and foo to datasets in a new JLD2 file named example.jld2. The @load macro loads variables out of a JLD2 file:","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"@load \"example.jld2\" hello foo","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"This assigns the contents of the hello and foo datasets to variables of the same name in the current scope.","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"It is best practice to explicitly name the variables to be loaded and saved from a file, so that it is clear from whence these variables arise. However, for convenience, JLD2 also provides variants of @load and @save that do not require variables to be named explicitly. When called with no variable arguments, @save <filename> writes all variables in the global scope of the current module to file <filename>, while @load <filename> loads all variables in file <filename>. When called with no variable arguments, @load requires that the file name is provided as a string literal, i.e., it is not possible to select the file at runtime.","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"Additional customization is possible using assignment syntax and option passing:","category":"page"},{"location":"legacy/","page":"Legacy","title":"Legacy","text":"@save \"example.jld2\" bye=hello bar=foo\n@save \"example.jld2\" {compress=true} hello bar=foo","category":"page"},{"location":"legacy/#JLD2.@save","page":"Legacy","title":"JLD2.@save","text":"@save filename var1 [var2 ...]\n@save filename {compress=true} var1 name2=var2\n\nWrite one or more variables var1,... from the current scope to a JLD2 file filename.\n\nFor interactive use you can save all variables in the current module's global scope using @save filename. More permanent code should prefer the explicit form to avoid saving unwanted variables.\n\nExample\n\nTo save the string hello and array xs to the JLD2 file example.jld2:\n\nhello = \"world\"\nxs = [1,2,3]\n@save \"example.jld2\" hello xs\n\nFor passing options to the saving command use {}\n\n@save \"example.jld2\" {compress=true} hello xs\n\nFor saving variables under a different name use regular assignment syntax\n\n@save \"example.jld2\" greeting=hello xarray = xs\n\n\n\n\n\n","category":"macro"},{"location":"legacy/#JLD2.@load","page":"Legacy","title":"JLD2.@load","text":"@load filename var1 [var2 ...]\n\nLoad one or more variables var1,... from JLD2 file filename into the current scope and return a vector of the loaded variable names.\n\nFor interactive use, the form @load \"somefile.jld2\" will load all variables from \"somefile.jld2\" into the current scope. This form only supports literal file names and should be avoided in more permanent code so that it's clear where the variables come from.\n\nExample\n\nTo load the variables hello and foo from the file example.jld2, use\n\n@load \"example.jld2\" hello foo\n\n\n\n\n\n","category":"macro"},{"location":"chunked_arrays/#Chunked-Arrays","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"JLD2.jl provides experimental support for chunked arrays, which break large datasets into smaller chunks for efficient storage and partial access patterns. This feature is particularly useful for large multi-dimensional arrays that exceed memory limits or when you only need to access portions of the data.","category":"page"},{"location":"chunked_arrays/#What-are-Chunked-Arrays?","page":"Chunked Arrays (Experimental)","title":"What are Chunked Arrays?","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Chunked arrays split large datasets into smaller, regularly-sized pieces called \"chunks.\" Each chunk is stored separately in the HDF5 file and can be:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Compressed independently for better storage efficiency\nAccessed individually without loading the entire dataset","category":"page"},{"location":"chunked_arrays/#Basic-Usage","page":"Chunked Arrays (Experimental)","title":"Basic Usage","text":"","category":"section"},{"location":"chunked_arrays/#Writing-Chunked-Arrays","page":"Chunked Arrays (Experimental)","title":"Writing Chunked Arrays","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"The simplest way to create chunked arrays is using the chunk keyword argument:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"using JLD2\n\n# Create a large 2D array\ndata = rand(1000, 2000)\n\n# Save with chunking - chunks of 100×200 elements each\njldopen(\"chunked_data.jld2\", \"w\") do f\n    f[\"large_array\"] = data\n    write(f, \"chunked_array\", data; chunk=(100, 200))\nend\n\nrm(\"chunked_data.jld2\", force=true) # hide\nnothing # hide","category":"page"},{"location":"chunked_arrays/#Chunking-with-Compression","page":"Chunked Arrays (Experimental)","title":"Chunking with Compression","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Combine chunking with compression for optimal storage:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"# Create repetitive data that compresses well\npattern_data = repeat([1.0, 2.0, 3.0, 4.0], 250, 500)\n\njldopen(\"compressed_chunks.jld2\", \"w\") do f\n    # Regular storage\n    f[\"uncompressed\"] = pattern_data\n\n    # Chunked with compression\n    write(f, \"compressed_chunked\", pattern_data;\n          chunk=(100, 200), compress=Deflate())\nend\n\n# Check file sizes\ninfo_uncompressed = stat(\"compressed_chunks.jld2\")\nprintln(\"File size: $(info_uncompressed.size) bytes\")\nrm(\"compressed_chunks.jld2\", force=true) # hide\nnothing # hide","category":"page"},{"location":"chunked_arrays/#Reading-Chunked-Arrays","page":"Chunked Arrays (Experimental)","title":"Reading Chunked Arrays","text":"","category":"section"},{"location":"chunked_arrays/#Standard-Reading","page":"Chunked Arrays (Experimental)","title":"Standard Reading","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Chunked arrays can be read normally - chunking is transparent to the user:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"# Create chunked data\ndata = collect(reshape(1:120, 10, 12))\n\njldopen(\"read_example.jld2\", \"w\") do f\n    write(f, \"chunked\", data; chunk=(5, 6))\nend\n\n# Read normally - chunking is transparent\nresult = jldopen(\"read_example.jld2\", \"r\") do f\n    f[\"chunked\"]\nend\n\nprintln(\"Original data size: $(size(data))\")\nprintln(\"Read data size: $(size(result))\")\nprintln(\"Data matches: $(data == result)\")\n\nrm(\"read_example.jld2\", force=true) # hide\nnothing # hide","category":"page"},{"location":"chunked_arrays/#Accessing-Individual-Chunks","page":"Chunked Arrays (Experimental)","title":"Accessing Individual Chunks","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"For advanced use cases, access individual chunks without loading the entire array:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"# Create test data\ntest_data = collect(reshape(1.0:60.0, 6, 10))\n\njldopen(\"chunk_access.jld2\", \"w\") do f\n    write(f, \"data\", test_data; chunk=(3, 5))\nend\n\n# Access chunks individually\njldopen(\"chunk_access.jld2\", \"r\") do f\n    chunked = JLD2.get_chunked_array(f, \"data\")\n\n    println(\"Chunk dimensions: $(JLD2.chunk_dimensions(chunked))\")\n    println(\"Total chunks: $(JLD2.num_chunks(chunked))\")\n    println(\"Chunk grid: $(JLD2.chunk_grid_size(chunked))\")\n\n    # Access first chunk\n    first_chunk = chunked[1, 1]\n    println(\"First chunk data:\\n$(first_chunk.data)\")\n    println(\"Chunk position: $(first_chunk.indices)\")\nend\n\nrm(\"chunk_access.jld2\", force=true) # hide\nnothing # hide","category":"page"},{"location":"chunked_arrays/#Iterating-Over-Chunks","page":"Chunked Arrays (Experimental)","title":"Iterating Over Chunks","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Process large datasets chunk by chunk to manage memory usage:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"# Create larger dataset\nlarge_data = collect(reshape(1:200, 10, 20))\n\njldopen(\"iterate_chunks.jld2\", \"w\") do f\n    write(f, \"large\", large_data; chunk=(5, 10))\nend\n\njldopen(\"iterate_chunks.jld2\", \"r\") do f\n    chunked = JLD2.get_chunked_array(f, \"large\")\n\n    println(\"Processing $(length(chunked)) chunks...\")\n\n    total_sum = 0.0\n    for (i, chunk) in enumerate(chunked)\n        chunk_sum = sum(chunk.data)\n        total_sum += chunk_sum\n        println(\"Chunk $i: sum = $chunk_sum, size = $(size(chunk.data))\")\n    end\n\n    println(\"Total sum across all chunks: $total_sum\")\n    println(\"Verification - direct sum: $(sum(large_data))\")\nend\n\nrm(\"iterate_chunks.jld2\", force=true) # hide\nnothing # hide","category":"page"},{"location":"chunked_arrays/#Advanced-Features","page":"Chunked Arrays (Experimental)","title":"Advanced Features","text":"","category":"section"},{"location":"chunked_arrays/#Error-Handling-and-Validation","page":"Chunked Arrays (Experimental)","title":"Error Handling and Validation","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"JLD2 validates chunk parameters and provides helpful error messages:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"invalid_data = [1, 2, 3, 4, 5]\n\ntry\n    jldopen(\"validation.jld2\", \"w\") do f\n        # This will fail - wrong number of chunk dimensions\n        write(f, \"data\", invalid_data; chunk=(2, 3))\n    end\ncatch e\n    println(\"Expected error: $(typeof(e))\")\n    println(\"Message: $(e.msg)\")\nend\n\n# Clean up any created file\nrm(\"validation.jld2\", force=true)\nnothing # hide","category":"page"},{"location":"chunked_arrays/#Performance-Considerations","page":"Chunked Arrays (Experimental)","title":"Performance Considerations","text":"","category":"section"},{"location":"chunked_arrays/#Choosing-Chunk-Sizes","page":"Chunked Arrays (Experimental)","title":"Choosing Chunk Sizes","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Optimal chunk sizes depend on your access patterns:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Sequential access: Use larger chunks (closer to 64KB-1MB per chunk)\nRandom access: Use smaller chunks for faster individual chunk reads\nCompression: Smaller chunks compress less efficiently but allow finer-grained access","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"# Example: comparing different chunk strategies\ndata_matrix = rand(1000, 1000)\n\njldopen(\"chunk_strategies.jld2\", \"w\") do f\n    # Strategy 1: Large chunks for sequential access\n    write(f, \"sequential\", data_matrix; chunk=(500, 500))\n\n    # Strategy 2: Smaller chunks for random access\n    write(f, \"random_access\", data_matrix; chunk=(100, 100))\n\n    # Strategy 3: Strip chunks for row-wise access\n    write(f, \"row_strips\", data_matrix; chunk=(50, 1000))\nend\n\nprintln(\"Different chunking strategies saved successfully\")\n\nrm(\"chunk_strategies.jld2\", force=true)\nnothing # hide","category":"page"},{"location":"chunked_arrays/#When-to-Use-Chunking","page":"Chunked Arrays (Experimental)","title":"When to Use Chunking","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Use chunking when:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Working with arrays larger than available memory\nNeed to access only portions of large datasets\nWant to apply compression to reduce file size\nBuilding incremental processing pipelines","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Avoid chunking when:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Arrays are small (< 64KB)\nAlways need to access the complete dataset\nWorking with 1D arrays (minimal benefit)","category":"page"},{"location":"chunked_arrays/#Compatibility","page":"Chunked Arrays (Experimental)","title":"Compatibility","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"Chunked arrays created by JLD2 are fully compatible with:","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"HDF5 ecosystem tools (h5dump, h5debug)\nPython h5py for cross-language access\nOther HDF5 libraries in C/C++, R, etc.","category":"page"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"The implementation follows the HDF5 specification for V1 B-tree indexed chunked datasets.","category":"page"},{"location":"chunked_arrays/#Current-Status","page":"Chunked Arrays (Experimental)","title":"Current Status","text":"","category":"section"},{"location":"chunked_arrays/","page":"Chunked Arrays (Experimental)","title":"Chunked Arrays (Experimental)","text":"⚠️ Note: Chunked array support is experimental. While the core functionality is stable, API and advanced features are still under development.","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/#Loading-plain-types","page":"Advanced Usage","title":"Loading plain types","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2 #hide\njldsave(\"test.jld2\"; z= 1.0 + im * 2.0)\nload(\"test.jld2\", \"z\")\nload(\"test.jld2\", \"z\"; plain=true)\n@__MODULE__","category":"page"},{"location":"advanced/#Explicit-Type-Remapping","page":"Advanced Usage","title":"Explicit Type Remapping","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Sometimes you store data using structs that you defined yourself or are shipped with some package and weeks later, when you want to load the data, the structs have changed.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2 #hide\nstruct A\n    x::Int\nend\njldsave(\"example.jld2\"; a = A(42))","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"This results in warnings and sometimes even errors when trying to load the file as demonstrated here.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2 #hide\nstruct A{T}\n    x::T\nend\nload(\"example.jld2\")","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The JLDFile struct contains a typemap field that allows for explicit type remapping. You can define a struct that matches the old definition and load your data.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2 #hide\nstruct A_old\n    x::Int\nend\nf = jldopen(\"example.jld2\",\"r\"; typemap=Dict(\"Main.A\" => A_old))\nf[\"a\"]","category":"page"},{"location":"advanced/#Upgrading-old-structures-on-load","page":"Advanced Usage","title":"Upgrading old structures on load","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The section above explains how you can make JLD2 load old structs with a different Datatype name as target. A different method for loading old data is described here:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2 #hide\n# This is the old version of the struct stored in the file\nstruct OldStructVersion\n    x::Int\n    y::Float64\nend\norig = OldStructVersion(1,2.0)\njldsave(\"test.jld2\"; data=orig)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using JLD2 #hide\n### new session\n\n# This is the new version of your struct\nstruct UpdatedStruct\n    x::Float64 # no longer int\n    y::Float64\n    z::Float64 # = x*y\nend\n\n# When upgrading a struct, JLD2 will load the fields of the old struct into a `NamedTuple`\n# and call `rconvert` on it. Here we implement a conversion method that returns an `UpdatedStruct`\nJLD2.rconvert(::Type{UpdatedStruct}, nt::NamedTuple) = UpdatedStruct(Float64(nt.x), nt.y, nt.x*nt.y)\n\n# Here we provide the `typemap` keyword argument. It is a dictionary mapping the stored struct name\n# to an `Upgrade` instance with the new struct.\nload(\"test.jld2\", \"data\"; typemap=Dict(\"Main.OldStructVersion\" => JLD2.Upgrade(UpdatedStruct)))","category":"page"},{"location":"advanced/#Full-control-over-type-reconstruction","page":"Advanced Usage","title":"Full control over type reconstruction","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The recommended and more powerful option is to take full control over type mapping by providing a custom mapping function that gets full access to all stored information including the type parameters. Example like above:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"struct OldStruct{T}\n    x::T\nend\n\nold_int = OldStruct(42)\nold_float = OldStruct(3.14)\njldsave(\"test.jld2\"; old_int, old_float, inttype=OldStruct{Int}, floattype=OldStruct{Float64}, )\n\nstruct NormalStruct{T}\n    x::T\nend\n\nstruct SquaredStruct{T}\n    xsquared::T\nend\n\nJLD2.rconvert(::Type{SquaredStruct{T}}, nt) where T = SquaredStruct{T}(nt.x^2)\n\ntypemap = function(f::JLD2.JLDFile, typepath::String, params::Vector)\n    if typepath == \"Main.OldStruct\"\n        if params[1] == Int\n            @info \"Mapping an OldStruct{Int} to SquaredStruct{Int} with conversion\"\n            # If the type param is Int, map to squared struct\n            # and wrap in `Upgrade` to trigger custom conversion with `rconvert`\n            return JLD2.Upgrade(SquaredStruct{Int})\n        else\n            @info \"Mapping an OldStruct{T} to NormalStruct{T} without conversion\"\n            # All other OldStructs just get updated to NormalStruct\n            return NormalStruct{params...}\n        end\n    end\n    # This typemap functino is called for every single type that is decoded.\n    # All types that do not need special handling should be forwarded to the default\n    # implementation.\n    @info \"Forwarding $typepath with parameters $params to default type mapping\"\n    return JLD2.default_typemap(f, typepath, params)\nend\n\nload(\"test.jld2\"; typemap)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ Info: Forwarding Core.Int64 with parameters Any[] to default type mapping\n[ Info: Mapping an OldStruct{Int} to SquaredStruct{Int} with conversion\n[ Info: Forwarding Core.Float64 with parameters Any[] to default type mapping\n[ Info: Mapping an OldStruct{T} to NormalStruct{T} without conversion\n[ Info: Forwarding Core.Int64 with parameters Any[] to default type mapping\n[ Info: Mapping an OldStruct{Int} to SquaredStruct{Int} with conversion\n[ Info: Forwarding Core.Float64 with parameters Any[] to default type mapping\n[ Info: Mapping an OldStruct{T} to NormalStruct{T} without conversion\nDict{String, Any} with 4 entries:\n  \"inttype\"   => SquaredStruct{Int64}\n  \"old_float\" => NormalStruct{Float64}(3.14)\n  \"old_int\"   => SquaredStruct{Int64}(1764)\n  \"floattype\" => NormalStruct{Float64}","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Note that the dictionary approach and the mapping function are mutually exclusive.","category":"page"},{"location":"advanced/#Groups-Appending-to-files","page":"Advanced Usage","title":"Groups - Appending to files","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Group objects can be constructed with two optional keyword arguments:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"g = Group(file;\n          est_num_entries=4\n          est_link_name_len=8)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"These determine how much (additional) empty space should be allocated for the group description. (list of entries) This can be useful for performance when one expects to append many additional datasets after first writing the file.","category":"page"},{"location":"advanced/#Fallback-Behaviour","page":"Advanced Usage","title":"Fallback Behaviour","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"By default JLD2 will attempt to open files using the MmapIO backend. If that fails, it retries using IOStream.","category":"page"},{"location":"basic_usage/#Basic-usages:-reading-and-writing-data","page":"Basic Usage","title":"Basic usages: reading and writing data","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"JLD2 provides a few different options to save and load data:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"FileIO interface\nSingle object storage\nFile handles\nUnPack Extension","category":"page"},{"location":"basic_usage/#FileIO-interface","page":"Basic Usage","title":"FileIO interface","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The save and load functions, provided by FileIO, are one of the simplest ways to use JLD2. The save function accepts an AbstractDict yielding the key/value pairs, where the key is a string representing the name of the dataset and the value represents its contents:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nsave(\"example.jld2\", Dict(\"hello\" => \"world\", \"foo\" => :bar))","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The save function can also accept the dataset names and contents as arguments:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nsave(\"example.jld2\", \"hello\", \"world\", \"foo\", :bar)","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"For save and load to automatically detect that you want to save a JLD2 file use the file suffix \".jld2\".","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"If called with a filename argument only, the load function loads all datasets from the given file into a Dict:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nload(\"example.jld2\")","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"When called with a single dataset name, load returns the contents of that dataset from the file:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nload(\"example.jld2\", \"hello\")","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"When called with multiple dataset names, load returns the contents of the given datasets as a tuple:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nload(\"example.jld2\", \"foo\", \"hello\")","category":"page"},{"location":"basic_usage/#jldsave","page":"Basic Usage","title":"jldsave","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"jldsave makes use of julia's keyword argument syntax to store files. This can be useful, when your data variables already have the correct name, e.g. use jldsave(file; variablename) instead of `save(file, \"variablename\", variablename)","category":"page"},{"location":"basic_usage/#JLD2.jldsave","page":"Basic Usage","title":"JLD2.jldsave","text":"jldsave(filename; kwargs...)\njldsave(filename, compress; kwargs...)\njldsave(filename, compress, iotype; kwargs...)\n\nCreates a JLD2 file at filename and stores the variables given as keyword arguments.\n\nExamples\n\njldsave(\"example.jld2\"; a=1, b=2, c)\n\nis equivalent to\n\njldopen(\"example.jld2\", \"w\") do f\n    f[\"a\"] = 1\n    f[\"b\"] = 2\n    f[\"c\"] = c\nend\n\nTo choose the io type IOStream instead of the default MmapIO use  jldsave(fn, IOStream; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"basic_usage/#Single-object-storage","page":"Basic Usage","title":"Single object storage","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"If only a single object needs to stored and loaded from a file, one can use save_object and load_object functions.","category":"page"},{"location":"basic_usage/#JLD2.save_object","page":"Basic Usage","title":"JLD2.save_object","text":"save_object(filename, x)\n\nStores an object x in a new JLD2 file at filename. If a file exists at this path, it will be overwritten.\n\nSince the JLD2 format requires that all objects have a name, the object will be stored as single_stored_object. If you want to store more than one object, use @save macro, jldopen or the FileIO API.\n\nExample\n\nTo save the string hello to the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\n\n\n\n\n\n","category":"function"},{"location":"basic_usage/#JLD2.load_object","page":"Basic Usage","title":"JLD2.load_object","text":"load_object(filename)\n\nReturns the only available object from the JLD2 file filename (The stored object name is inconsequential). If the file contains more than one or no objects, the function throws an ArgumentError.\n\nFor loading more than one object, use @load macro, jldopen or the FileIO API.\n\nExample\n\nTo load the only object from the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\nhello_loaded = load_object(\"example.jld2\")\n\n\n\n\n\n","category":"function"},{"location":"basic_usage/#File-handles","page":"Basic Usage","title":"File handles","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"It is also possible to interact with JLD2 files using a file-like interface. The jldopen function accepts a file name and an argument specifying how the file should be opened:","category":"page"},{"location":"basic_usage/#JLD2.jldopen","page":"Basic Usage","title":"JLD2.jldopen","text":"jldopen(file, mode::AbstractString; iotype=MmapIO, compress=false, typemap=JLD2.default_typemap)\n\nOpens a JLD2 file at path file. Alternatively file may be a suitable IO object.\n\nOptions for mode:\n\n\"r\": Open for reading only, failing if no file exists\n\"r+\": Open for reading and writing, failing if no file exists\n\"w\"/\"w+\": Open for reading and writing, overwriting the file if it already exists\n\"a\"/\"a+\": Open for reading and writing, creating a new file if none exists, but               preserving the existing file if one is present\n\n\n\n\n\n","category":"function"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Data can be written to the file using write(f, \"name\", data) or f[\"name\"] = data, or read from the file using read(f, \"name\") or f[\"name\"]. When you are done with the file, remember to call close(f).","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Like open, jldopen also accepts a function as the first argument, permitting do-block syntax:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\njldopen(\"example.jld2\", \"w\") do f\n    write(f, \"variant1\", 1.0)\n    f[\"variant2\"] = (rand(5), rand(Bool, 3))\nend\n\nf = jldopen(\"example.jld2\")\nv1 = read(f, \"variant1\")\nv2 = f[\"variant2\"]\nclose(f)\nv1, v2","category":"page"},{"location":"basic_usage/#Groups","page":"Basic Usage","title":"Groups","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"JLD2 files allow for nesting datasets into groups which may be useful for organizing your data. You may construct groups explicitly:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\njldopen(\"example.jld2\", \"w\") do file\n    mygroup = JLD2.Group(file, \"mygroup\")\n    mygroup[\"mystuff\"] = 42\n    display(file)\nend","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"or implicitly, by saving a variable with a name containing slashes as path delimiters:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nsave(\"example.jld2\", \"mygroup/mystuff\", 42)","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Similarly, you can access groups directly:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\njldopen(\"example.jld2\") do file\n    file[\"mygroup\"][\"mystuff\"]\nend","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"or using slashes as path delimiters:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2\nload(\"example.jld2\", \"mygroup/mystuff\")","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"When loading files with nested groups these will be unrolled into paths by default but yield nested dictionaries but with the nested keyword argument.","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"load(\"example.jld2\")\nload(\"example.jld2\"; nested=true)","category":"page"},{"location":"basic_usage/#UnPack-Extension","page":"Basic Usage","title":"UnPack Extension","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"When additionally loading the UnPack.jl package, its @unpack and @pack! macros can be used to quickly save and load data from the file-like interface. Example:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using JLD2, UnPack\nfile = jldopen(\"example.jld2\", \"w\")\nx, y = rand(2)\n\n@pack! file = x, y # equivalent to file[\"x\"] = x; file[\"y\"] = y\n@unpack x, y = file # equivalent to x = file[\"x\"]; y = file[\"y\"]\nclose(file)","category":"page"},{"location":"hdf5compat/#HDF5-Compatibility","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"JLD2 is built upon the HDF5 Format Specification and produces files that are compatible with the official HDF5 C library.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"This has the advantage that other libraries that use HDF5 such as the Julia wrapper HDF5.jl or  even with h5py using Python. In addition to that, adhering to the HDF5 standards allows you to use the file introspection tools  such as h5dump and h5debug provided by the HDF5 group.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"warning: Warning\nGeneral compatibility only holds for a list of basic types:Numbers FloatXX, IntXX and UIntXX\nBools\nStrings\nArrays of those typesOther structures can in principle also be decoded but may involve work. See below for more information","category":"page"},{"location":"hdf5compat/#Understanding-how-Julia-structs-are-encoded","page":"HDF5 Compatibility","title":"Understanding how Julia structs are encoded","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"The HDF5 standard supports so-called compound datatypes that comprise of a set of  already known datatypes. This is very similar to julia's structs.  When a user wants to write a non-default type to disk then JLD2 will create the corresponding compound datatypes and commit them to the file. All custom type definitions in a JLD2 file will be stored  in a _types/ group. This way, the type definitions only needs to be written to the file once and all instances of that struct reference it.","category":"page"},{"location":"hdf5compat/#Example","page":"HDF5 Compatibility","title":"Example","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"using JLD2\n\nstruct MyCustomStruct\n    x::Int64\n    y::Float64\nend\n\n@save \"test.jld2\" a=MyCustomStruct(42, π)","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"Let's see what JLD2 makes out of my simple MyCustomStruct. To do that we view the output of h5dump","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"$ h5dump test.jld2\nHDF5 \"test.jld2\" {\nGROUP \"/\" {\n   GROUP \"_types\" {\n      DATATYPE \"00000001\" H5T_COMPOUND {\n         H5T_STRING {\n            STRSIZE H5T_VARIABLE;\n            STRPAD H5T_STR_NULLPAD;\n            CSET H5T_CSET_UTF8;\n            CTYPE H5T_C_S1;\n         } \"name\";\n         H5T_VLEN { H5T_REFERENCE { H5T_STD_REF_OBJECT }} \"parameters\";\n      }\n         ATTRIBUTE \"julia_type\" {\n            DATATYPE  \"/_types/00000001\"\n            DATASPACE  SCALAR\n            DATA {\n            (0): {\n                  \"Core.DataType\",\n                  ()\n               }\n            }\n         }\n      DATATYPE \"00000002\" H5T_COMPOUND {\n         H5T_STD_I64LE \"x\";\n         H5T_IEEE_F64LE \"y\";\n      }\n         ATTRIBUTE \"julia_type\" {\n            DATATYPE  \"/_types/00000001\"\n            DATASPACE  SCALAR\n            DATA {\n            (0): {\n                  \"Main.MyCustomStruct\",\n                  ()\n               }\n            }\n         }\n   }\n   DATASET \"a\" {\n      DATATYPE  \"/_types/00000002\"\n      DATASPACE  SCALAR\n      DATA {\n      (0): {\n            42,\n            3.14159\n         }\n      }\n   }\n}\n}","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"We can see that the file contains two things at top-level. There is a dataset \"a\" (that is what we wanted to store) and there is a group _types which is where all the necessary type information is stored.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"You can see that JLD2 committed two compound datatypes. The first one is Core.Datatype which at first seems rather unintuitive. It is needed to tell HDF5 what a serialized  julia datatype looks like (a name and a list of parameters).","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"Below that is the definition of MyCustomStruct with two fields  H5T_STD_I64LE \"x\" and H5T_IEEE_F64LE \"y\" defining the integer field x and the float field y.","category":"page"},{"location":"hdf5compat/#A-note-on-pointers","page":"HDF5 Compatibility","title":"A note on pointers","text":"","category":"section"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"In the julia programming language pointers Ptr are not needed very often. However, when binary dependencies come into play and memory is passed back and forth, pointers do become relevant. Pointers are addresses to locations in memory and thus lose their meaning after a program has terminated.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"In principle, there is little point in storing a pointer to a file but in order to allow for a more seamless experience JLD2 will, similar to Base.Serialization silently accept pointers. This is useful when storing large structures such as a DifferentialEquations.jl solution object that might contain a pointer somewhere. Upon deserialization any pointer fields are instantiated as null pointers.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"This is done with just three lines of code utilizing the custom serialization logic and  it is shown here as it serves as a good example for usage of that feature.","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"writeas(::Type{<:Ptr}) = Nothing\nrconvert(::Type{Ptr{T}}, ::Nothing) where {T} = Ptr{T}()","category":"page"},{"location":"hdf5compat/","page":"HDF5 Compatibility","title":"HDF5 Compatibility","text":"Usually one would also have to define a method for wconvert. However, in this  case JLD2 figures out that no explicit conversion is needed to construct nothing.","category":"page"},{"location":"internals/#Internals-and-Design","page":"Internals & Design","title":"Internals & Design","text":"","category":"section"},{"location":"internals/#File-Interface","page":"Internals & Design","title":"File Interface","text":"","category":"section"},{"location":"internals/","page":"Internals & Design","title":"Internals & Design","text":"The JLDFile object mimics the API of Base.Dict as much as it can. In particular, keys, length, haskey, isempty, get, get! should work as expected.","category":"page"},{"location":"internals/#JLD2.TYPE_AS_DATA","page":"Internals & Design","title":"JLD2.TYPE_AS_DATA","text":"TYPE_AS_DATA::ScopedValue{Bool}\n\nSignal to the jlconvert function that the type being read will be treated as either data or a type. This is needed to allow a custom typemap function to return an Upgrade object when the type is going to be used for reconstructing an instance. (as a type)\n\n\n\n\n\n","category":"constant"},{"location":"internals/#JLD2.AbstractLink","page":"Internals & Design","title":"JLD2.AbstractLink","text":"AbstractLink\n\nAbstract base type for all link types in JLD2. Links represent connections between names in groups and objects or paths in the HDF5 file structure.\n\nThe concrete subtypes are:\n\nHardLink: Direct pointer to an object header (traditional JLD2 behavior)\nSoftLink: Path string resolved at access time within the same file\nExternalLink: Reference to an object in a different HDF5 file\n\nSee the HDF5 specification section 3.2.J for complete link message format details.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Chunk","page":"Internals & Design","title":"JLD2.Chunk","text":"Chunk{T,N}\n\nRepresents a single chunk of data with its metadata.\n\nFields\n\ndata::Array{T,N} - The actual chunk data\nindices::CartesianIndex{N} - Starting index of the chunk in the full array (1-based)\nchunk_indices::CartesianIndex{N} - Chunk grid position (1-based)\noffset::RelOffset - File offset where the chunk data is stored\nsize::Int - Size of the chunk data in bytes\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.ChunkInfo","page":"Internals & Design","title":"JLD2.ChunkInfo","text":"ChunkInfo\n\nMetadata for a single chunk in the B-tree.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.ChunkedArray","page":"Internals & Design","title":"JLD2.ChunkedArray","text":"ChunkedArray{T,N}\n\nLazy wrapper around a chunked dataset that allows iterating over individual chunks without loading the entire array into memory.\n\nFields\n\nfile::JLDFile - The JLD2 file containing the dataset\ndataset_offset::RelOffset - Offset of the dataset header\narray_size::NTuple{N,Int} - Size of the full array\nchunk_dims::NTuple{N,Int} - Dimensions of each chunk\ndatatype::H5Datatype - HDF5 datatype of the array\nlayout::DataLayout - Data layout information (must be chunked)\nfilters::FilterPipeline - Compression filters applied to chunks\nrr::ReadRepresentation{T} - Read representation for deserialization\nchunks::Vector{ChunkInfo} - Parsed chunk metadata from B-tree\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.CommittedDatatype","page":"Internals & Design","title":"JLD2.CommittedDatatype","text":"CommittedDatatype <: H5Datatype\n\nReference to a shared datatype message (stored elsewhere in a file). These are stored in the _types group and indexed.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.CustomSerialization","page":"Internals & Design","title":"JLD2.CustomSerialization","text":"CustomSerialization{T,S}\n\nOn-disk representation for data that is written as if it were of Julia type T, but is read as type S.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.ExternalFileHandle","page":"Internals & Design","title":"JLD2.ExternalFileHandle","text":"ExternalFileHandle\n\nRepresents a handle to an external file that can be shared across multiple external links. Includes error handling for various failure conditions.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.ExternalLink","page":"Internals & Design","title":"JLD2.ExternalLink","text":"ExternalLink <: AbstractLink\n\nRepresents an external link that references an object in a different HDF5 file. This enables cross-file data dependencies and modular file organization.\n\nFields\n\nfile_path::String: Path to the external HDF5 file (relative or absolute)\nobject_path::String: Path within the external file to the target object\n\nHDF5 Details\n\nExternal links correspond to HDF5 link type 64. They contain two null-terminated strings: the external file path and the object path within that file.\n\nExample\n\n# Link to /data/temperature in external_file.h5\nlink = ExternalLink(\"./external_file.h5\", \"/data/temperature\")\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.GlobalHeap","page":"Internals & Design","title":"JLD2.GlobalHeap","text":"GlobalHeap\n\nRepresents an HDF5 global heap structure.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Group","page":"Internals & Design","title":"JLD2.Group","text":"Group(file::JLDFile, name::String)\nGroup(file::Group, name::String)\n\nConstruct a Group in file with name name. Groups are JLD2s equivalent of folders and may be nested, so file itself may alread be a Group or a JLDFile file handle.\n\nExample usage\n\njldopen(\"example.jld2\", \"w\") do f\n    g = Group(f, \"subgroup\")\n    g[\"data\"] = 42\nend\n\njldopen(\"example.jld2\") do f\n    g = f[\"subgroup\"]\n    f[\"subgroup/data\"] == g[\"data\"]\nend\n\nKeyword arguments:\n\nest_num_entries::Int = 4\nest_link_name_len::Int = 8\n\nDetermine how much (additional) empty space should be allocated for the group description. (list of entries) This can be useful for performance when one expects to append many additional datasets after first writing the file.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Group-Tuple{JLD2.JLDFile, AbstractString}","page":"Internals & Design","title":"JLD2.Group","text":"Group(f::JLDFile, name::AbstractString)\n\nConstruct an empty group named name at the top level of JLDFile f.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.Group-Union{Tuple{T}, Tuple{JLD2.Group{T}, AbstractString}} where T","page":"Internals & Design","title":"JLD2.Group","text":"Group(g::Group, name::AbstractString)\n\nConstruct a group named name as a child of group g.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.H5Datatype","page":"Internals & Design","title":"JLD2.H5Datatype","text":"abstract type H5Datatype\n\nSupertype of all HDF5 datatypes.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.HardLink","page":"Internals & Design","title":"JLD2.HardLink","text":"HardLink <: AbstractLink\n\nRepresents a hard link that points directly to an object header within the same file. This is the traditional link type used throughout JLD2 and maintains backward compatibility.\n\nFields\n\ntarget::RelOffset: The file offset where the target object header is located\n\nHDF5 Details\n\nHard links correspond to HDF5 link type 0. They contain a direct address pointer to the object header, making access very efficient but preventing cross-file references.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.HeaderMessage","page":"Internals & Design","title":"JLD2.HeaderMessage","text":"HeaderMessage\n\nHelper struct to read and write the first part of a header message.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.HeaderMessageIterator","page":"Internals & Design","title":"JLD2.HeaderMessageIterator","text":"mutable struct HeaderMessageIterator{IO}\nHeaderMessageIterator(f::JLDFile, offset::RelOffset)\n\nImplements an iterator over header messages.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Hmessage","page":"Internals & Design","title":"JLD2.Hmessage","text":"Hmessage{IO}\n\nRepresentation of a Header Message in memory. Provides getproperty access to the fields of the message. Can also be used to construct and write custom messages.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.IndirectPointer","page":"Internals & Design","title":"JLD2.IndirectPointer","text":"IndirectPointer\n\nWhen writing data, we may need to enlarge the memory mapping, which would invalidate any memory addresses arising from the old mmap pointer. IndirectPointer holds an offset relative to the MemoryBackedIO. It defers computing a memory address until converted to a Ptr{T}, so the memory mapping can be enlarged and addresses will remain valid.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.InlineUnionEl","page":"Internals & Design","title":"JLD2.InlineUnionEl","text":"InlineUnionEl{T1,T2}(mask::UInt8, t1::T1, t2::T2)\n\nCustom serialization struct for two member isbits union fields e.g. in other structs or arrays. To indicate that t1 is relevant the mask takes the value UInt8(0) and for t2 the mask takes the value UInt8(255).\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.JLDFile","page":"Internals & Design","title":"JLD2.JLDFile","text":"JLDFile{T<:IO}\n\nJLD file object.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.JLDWriteSession","page":"Internals & Design","title":"JLD2.JLDWriteSession","text":"JLDWriteSession{T}\n\nA JLDWriteSession keeps track of references to serialized objects. If T is a Dict, h5offset maps an object ID (returned by calling objectid) to th RelOffset of the written dataset. If it is Union{}, then references are not tracked, and objects referenced multiple times are written multiple times.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.MemoryBackedIO","page":"Internals & Design","title":"JLD2.MemoryBackedIO","text":"MemoryBackedIO <: IO\n\nAbstract type for IO objects that are backed by memory in such a way that one can use pointer based unsafe_load and unsafe_store! operations after ensuring that there is enough memory allocated.\n\nIt needs to provide:\n\ngetproperty(io, :curptr) to get the current pointer\nensureroom(io, nb) to ensure that there are at least nb bytes available\nposition(io) to get the current (zero-based) position\nseek(io, pos) to set the current position (zero-based)\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Message","page":"Internals & Design","title":"JLD2.Message","text":"Message{IO}\n\nRepresentation of a Message in memory. Provides getproperty access\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.ReadRepresentation","page":"Internals & Design","title":"JLD2.ReadRepresentation","text":"ReadRepresentation{T,ODR}\n\nA type encoding both the Julia type T and the on-disk (HDF5) representation ODR.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.RelOffset","page":"Internals & Design","title":"JLD2.RelOffset","text":"RelOffset\n\nRepresents an HDF5 relative offset. This differs from a file offset (used elsewhere) in that it is relative to the superblock base address. fileoffset and h5offset convert between RelOffsets and file offsets.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.SharedDatatype","page":"Internals & Design","title":"JLD2.SharedDatatype","text":"SharedDatatype <: H5Datatype\n\nReference to a shared datatype message (stored elsewhere in a file).\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.SoftLink","page":"Internals & Design","title":"JLD2.SoftLink","text":"SoftLink <: AbstractLink\n\nRepresents a soft link that contains a path string resolved at access time. The path can be absolute (starting with '/') or relative to the containing group.\n\nFields\n\npath::String: The path to resolve when the link is accessed\n\nHDF5 Details\n\nSoft links correspond to HDF5 link type 1. They contain a path string that is resolved when the link is dereferenced, allowing for more flexible file organization but requiring path resolution overhead.\n\nPath Format\n\nAbsolute paths: /group/subgroup/dataset\nRelative paths: ../other_group/dataset\nPath separator is always '/' regardless of platform\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.Upgrade","page":"Internals & Design","title":"JLD2.Upgrade","text":"Upgrade(T)\n\nSpecify an upgrade path for serialized structs using the typemap keyword argument and rconvert.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.V1BTree","page":"Internals & Design","title":"JLD2.V1BTree","text":"V1BTree\n\nHelper structure for managing the entire V1 B-tree.\n\nroot: Address of root node\ndimensionality: Number of dimensions in dataset\nmaxentriesper_node: Based on desired node size\nfile: Reference to file for I/O\npending_chunks: Chunks waiting to be written to the tree\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.V1BTreeNode","page":"Internals & Design","title":"JLD2.V1BTreeNode","text":"V1BTreeNode\n\nCore node structure for V1 B-trees.\n\nnode_type: 1 for chunked datasets, 0 for groups\nnode_level: 0 for leaf, >0 for internal nodes\nentries_used: Number of valid key/child pairs\nleftsibling: Left sibling node address (UNDEFINEDADDRESS if none)\nrightsibling: Right sibling node address (UNDEFINEDADDRESS if none)\nkeys: Keys (length = entries_used + 1)\nchildren: Child addresses (length = entries_used)\n\nHDF5 ordering rule for chunked datasets (type 1): Key[i] describes the least chunk in Child[i]\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2.V1ChunkKey","page":"Internals & Design","title":"JLD2.V1ChunkKey","text":"V1ChunkKey\n\nKey structure for chunked datasets in V1 B-trees. Each key contains:\n\nchunk_size: Size of chunk in bytes (UInt32)\nfilter_mask: Bitmask indicating which filters were applied (UInt32)\nindices: D+1 dimensional indices where D is dimensionality (Vector{UInt64}) The last index is always 0 (datatype offset)\n\nExample: For a 3D chunk at position [5,5,5], indices = [5, 5, 5, 0]\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLD2._read_chunk-Union{Tuple{N}, Tuple{T}, Tuple{ChunkedArray{T, N}, CartesianIndex{N}}} where {T, N}","page":"Internals & Design","title":"JLD2._read_chunk","text":"_read_chunk(ca::ChunkedArray, chunk_idx::CartesianIndex)\n\nInternal function to read a specific chunk from the file.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2._read_chunk_data-Union{Tuple{T}, Tuple{JLD2.JLDFile, Any, Type{T}, Any, Any, Any}} where T","page":"Internals & Design","title":"JLD2._read_chunk_data","text":"_read_chunk_data(f::JLDFile, chunk_info, T, chunk_dims, rr, filters)\n\nRead and decompress chunk data from file.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.apply_chunk_filters-Tuple{JLD2.Filters.FilterPipeline, Vector{UInt8}}","page":"Internals & Design","title":"JLD2.apply_chunk_filters","text":"apply_chunk_filters(filters::FilterPipeline, chunk_data::Vector{UInt8})::Tuple{Vector{UInt8}, UInt32}\n\nApply compression filters to a single chunk and return the compressed data and filter mask. Uses the JLD2.Filters module to apply compression correctly.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.attributes-Tuple{JLD2.Dataset}","page":"Internals & Design","title":"JLD2.attributes","text":"attributes(dset::Dataset; plain::Bool=false)\n\nReturn the attributes of a dataset as an OrderedDict. If plain is set to true then the values are returned as stored in the dataset object.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.behead-Tuple{UnionAll}","page":"Internals & Design","title":"JLD2.behead","text":"behead(T)\n\nGiven a UnionAll type, recursively eliminates the where clauses\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.bufferpos-Tuple{Union{JLD2.BufferedReader, JLD2.BufferedWriter}}","page":"Internals & Design","title":"JLD2.bufferpos","text":"bufferpos(io::Union{BufferedReader, BufferedWriter})\n\nGet the current position in the buffer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.build_btree_from_chunks-Tuple{JLD2.JLDFile, Vector{JLD2.V1ChunkKey}, Vector{JLD2.RelOffset}, UInt16}","page":"Internals & Design","title":"JLD2.build_btree_from_chunks","text":"build_btree_from_chunks(file::JLDFile, keys::Vector{V1ChunkKey}, children::Vector{RelOffset}, max_entries::UInt16)\n\nBuild a B-tree from a large number of chunks that need to be split across multiple nodes. Returns the root node offset.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.calculate_key_size-Tuple{JLD2.V1ChunkKey}","page":"Internals & Design","title":"JLD2.calculate_key_size","text":"calculate_key_size(key::V1ChunkKey)::Int\n\nCalculate the size in bytes needed to serialize a V1 chunk key.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.calculate_max_entries","page":"Internals & Design","title":"JLD2.calculate_max_entries","text":"calculate_max_entries(f::JLDFile, dimensionality::UInt8, target_node_size::Int = 4096)::UInt16\n\nCalculate the maximum number of entries that can fit in a V1 B-tree node for the given dimensionality and target node size.\n\nAlgorithm:\n\nCalculate fixed overhead (signature, header, sibling pointers)\nCalculate size per entry (key + child pointer)\nAccount for extra key at end\nDetermine max entries that fit in target size\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.calculate_max_entries_theoretical","page":"Internals & Design","title":"JLD2.calculate_max_entries_theoretical","text":"calculate_max_entries_theoretical(dimensionality::UInt8, node_size::Int = 4096)\n\nCalculate theoretical maximum entries for comparison with h5debug output.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.calculate_node_size-Tuple{JLD2.V1BTreeNode}","page":"Internals & Design","title":"JLD2.calculate_node_size","text":"calculate_node_size(node::V1BTreeNode)::Int\n\nCalculate the total size in bytes needed to serialize a V1 B-tree node.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.chunk_dimensions-Tuple{ChunkedArray}","page":"Internals & Design","title":"JLD2.chunk_dimensions","text":"chunk_dimensions(ca::ChunkedArray) -> NTuple\n\nGet the dimensions of each chunk.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.chunk_grid_size-Union{Tuple{ChunkedArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Internals & Design","title":"JLD2.chunk_grid_size","text":"chunk_grid_size(ca::ChunkedArray) -> NTuple\n\nGet the dimensions of the chunk grid (number of chunks in each dimension).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.clear_external_file_cache-Tuple{}","page":"Internals & Design","title":"JLD2.clear_external_file_cache","text":"clear_external_file_cache()\n\nClear the external file cache and close all cached files. This is useful for cleanup or when memory usage needs to be reduced.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.compare_chunk_keys-Tuple{JLD2.V1ChunkKey, JLD2.V1ChunkKey}","page":"Internals & Design","title":"JLD2.compare_chunk_keys","text":"compare_chunk_keys(key1::V1ChunkKey, key2::V1ChunkKey)::Int\n\nCompare two chunk keys for sorting in V1 B-trees. Returns: -1 if key1 < key2, 0 if equal, +1 if key1 > key2\n\nFor chunked datasets: Key[i] describes the least chunk in Child[i] Keys are compared lexicographically by dimension indices (excluding final datatype offset).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.construct_array-Union{Tuple{T}, Tuple{IO, Type{T}, Int64}} where T","page":"Internals & Design","title":"JLD2.construct_array","text":"construct_array(io::IO, eltype, ndims::Int)\n\nConstruct array by reading ndims dimensions from io. Assumes io has already been seeked to the correct position.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.constructrr","page":"Internals & Design","title":"JLD2.constructrr","text":"constructrr(f::JLDFile, T::DataType, dt::CompoundType, attrs::Vector{ReadAttribute},\n            hard_failure::Bool=false)\n\nConstructs a ReadRepresentation for a given type. This is the generic method for all types not specially handled below.\n\nIf hard_failure is true, then throw a TypeMappingException instead of attempting reconstruction. This helps in cases where we can't know if reconstructed parametric types will have a matching memory layout without first inspecting the memory layout.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.create_chunk_key","page":"Internals & Design","title":"JLD2.create_chunk_key","text":"create_chunk_key(chunk_indices::Vector{Int}, chunk_size::UInt32, filter_mask::UInt32 = 0x00000000)::V1ChunkKey\n\nCreate a V1 B-tree chunk key from chunk indices and metadata. Automatically appends the required datatype offset (always 0) to the indices.\n\nNOTE: HDF5 stores dimensions in reverse order (fastest to slowest). The chunk indices must be reversed to match HDF5 expectations before storing as 0-based. The reading code in datasets.jl will reverse them back and convert to 1-based ranges.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.create_dataset-Tuple{JLD2.JLDFile, Vararg{Any}}","page":"Internals & Design","title":"JLD2.create_dataset","text":"create_dataset(parent, path, datatype, dataspace; kwargs...)\n\nArguments:     - parent::Union{JLDfile, Group}: Containing group of new dataset     - path: Path to new dataset relative to parent. If path is nothing, the dataset is unnamed.     - datatype: Datatype of new dataset (element type in case of arrays)     - dataspace: Dimensions or Dataspace of new dataset\n\nKeyword arguments:     - layout: DataLayout of new dataset     - filters: FilterPipeline for describing the compression pipeline\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.create_external_link!-Tuple{JLD2.Group, String, String, String}","page":"Internals & Design","title":"JLD2.create_external_link!","text":"create_external_link!(group::Group, link_name::String, file_path::String, object_path::String)\n\nCreate an external link in the group that points to an object in another HDF5/JLD2 file.\n\nArguments\n\ngroup::Group: The group to create the link in\nlink_name::String: Name of the link within the group\nfile_path::String: Path to the external HDF5/JLD2 file\nobject_path::String: Path to the object within the external file\n\nExample\n\nusing JLD2\n\n# Open a file and create an external link\njldopen(\"main.jld2\", \"w\") do file\n    create_external_link!(file, \"external_data\", \"data.jld2\", \"/dataset1\")\nend\n\nNote: External file paths are validated to prevent directory traversal attacks.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.create_initial_root-Tuple{JLD2.JLDFile, JLD2.V1ChunkKey, JLD2.RelOffset, JLD2.V1BTree}","page":"Internals & Design","title":"JLD2.create_initial_root","text":"create_initial_root(f::JLDFile, key::V1ChunkKey, child_address::RelOffset, btree::V1BTree)::RelOffset\n\nCreate the initial root node for an empty B-tree. Returns the offset where the root node was written.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.create_new_root-Tuple{JLD2.JLDFile, JLD2.RelOffset, JLD2.RelOffset, JLD2.V1ChunkKey, JLD2.V1BTree}","page":"Internals & Design","title":"JLD2.create_new_root","text":"create_new_root(f::JLDFile, old_root_offset::RelOffset, new_child_offset::RelOffset,\n               promoted_key::V1ChunkKey, btree::V1BTree)::RelOffset\n\nCreate a new root node when the old root was split. The new root will have the old root and new child as its children. Returns the offset where the new root was written.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.create_soft_link!-Tuple{JLD2.Group, String, String}","page":"Internals & Design","title":"JLD2.create_soft_link!","text":"create_soft_link!(group::Group, link_name::String, target_path::String)\n\nCreate a soft link (symbolic link) within the same HDF5/JLD2 file.\n\nArguments\n\ngroup::Group: The group to create the link in\nlink_name::String: Name of the link within the group\ntarget_path::String: Path to the target object within the same file\n\nExample\n\nusing JLD2\n\njldopen(\"test.jld2\", \"w\") do file\n    file[\"original_data\"] = [1, 2, 3, 4, 5]\n    create_soft_link!(file, \"link_to_data\", \"/original_data\")\nend\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.debug_v1btree_file-Tuple{String, String}","page":"Internals & Design","title":"JLD2.debug_v1btree_file","text":"debug_v1btree_file(filename::String, dataset_name::String)\n\nDebug a complete JLD2 file's V1 B-tree structure.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.default_typemap-Tuple{JLD2.JLDFile, String, Vector}","page":"Internals & Design","title":"JLD2.default_typemap","text":"default_typemap(f::JLDFile, typepath::String, params)\n\nDefault type mapping function used by JLD2 to resolve data types read from files.\n\nArguments:\n\nf::JLDFile: The JLD file being read.\ntypepath::String: The path to the type as a string, e.g. \"Main.MyModule.MyType\".\nparams: A list of type parameters for the type (may be empty).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.detect_circular_reference-Tuple{String, String}","page":"Internals & Design","title":"JLD2.detect_circular_reference","text":"detect_circular_reference(current_file_path::String, external_file_path::String)\n\nSophisticated circular reference detection that tracks the full chain of external references.\n\nArguments\n\ncurrent_file_path: Path to the current file\nexternal_file_path: Path to the external file being opened\n\nThrows\n\nUnsupportedFeatureException if a circular reference is detected.\n\nAlgorithm\n\nUses task-local storage to maintain a reference chain of currently opening files. This catches both direct circular references (A -> A) and longer chains (A -> B -> C -> A).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.enumerate_chunks-Tuple{Any, Any}","page":"Internals & Design","title":"JLD2.enumerate_chunks","text":"enumerate_chunks(data_size::NTuple{N,Int}, chunk_dims::Vector{Int}) where N\n\nEnumerate all chunk indices for a given data size and chunk dimensions. Returns an iterator over chunk indices.\n\nExample: julia> JLD2.enumerate_chunks((10,14), [3,5]) |> collect 4×3 Matrix{Tuple{Int64, Int64}}:  (1, 1)   (1, 6)   (1, 11)  (4, 1)   (4, 6)   (4, 11)  (7, 1)   (7, 6)   (7, 11)  (10, 1)  (10, 6)  (10, 11)`\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.extract_chunk-Tuple{Any, Any, Any}","page":"Internals & Design","title":"JLD2.extract_chunk","text":"extract_chunk(data, chunk_indices::Vector{Int}, chunk_dims::Vector{Int})\n\nExtract a chunk of data at the given chunk starting positions with the specified chunk dimensions. Returns the chunk data as a contiguous array.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.fileoffset-Tuple{JLD2.JLDFile, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.fileoffset","text":"fileoffset(f::JLDFile, x::RelOffset)\n\nConverts an offset x relative to the superblock of file f to an absolute offset.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.finalize_btree!-Tuple{JLD2.V1BTree, Any}","page":"Internals & Design","title":"JLD2.finalize_btree!","text":"finalize_btree!(btree::V1BTree)\n\nFinalize the B-tree by writing all pending chunks. If there are more chunks than can fit in a single node, creates multiple nodes with proper B-tree structure.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.find_child_for_key-Tuple{JLD2.V1BTreeNode, JLD2.V1ChunkKey}","page":"Internals & Design","title":"JLD2.find_child_for_key","text":"find_child_for_key(node::V1BTreeNode, key::V1ChunkKey)::Int\n\nFind which child pointer to follow for a given key in an internal node. Returns the child index (1-based) to traverse.\n\nUses the V1 B-tree ordering rule: Key[i] describes the least chunk in Child[i]\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.find_group_path_simple-Tuple{JLD2.Group, JLD2.Group, String}","page":"Internals & Design","title":"JLD2.find_group_path_simple","text":"find_group_path_simple(root::Group, target::Group, current_path::String) -> String\n\nFind the path to a target group using recursion through both unwritten and written groups. This version searches both in-memory and disk-based groups to find the target.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.find_insertion_point-Tuple{JLD2.V1BTreeNode, JLD2.V1ChunkKey}","page":"Internals & Design","title":"JLD2.find_insertion_point","text":"find_insertion_point(node::V1BTreeNode, key::V1ChunkKey)::Int\n\nFind the correct insertion point for a key in a node using binary search. Returns the index where the key should be inserted (1-based indexing).\n\nFor V1 B-trees with chunked datasets, maintains the ordering invariant: Key[i] describes the least chunk in Child[i]\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.find_type-Tuple{String}","page":"Internals & Design","title":"JLD2.find_type","text":"find_type(typepath::String)\n\nFinds a type in the loaded modules by its path as a string. The type path should be a dot-separated string, e.g. \"Main.MyModule.MyType\". If the type is found, it returns the corresponding DataType or UnionAll. If the type is not found, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.flag2uint-Tuple{UInt8}","page":"Internals & Design","title":"JLD2.flag2uint","text":"flag2uint(flag::UInt8)\n\nI Map the lowest to bits of flag to a UInt type, mapping 0 to UInt8, 1 to UInt16, 2 to UInt32, and 3 to UInt64.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_cache_stats-Tuple{}","page":"Internals & Design","title":"JLD2.get_cache_stats","text":"get_cache_stats() -> NamedTuple\n\nGet statistics about the external file cache for debugging and monitoring.\n\nReturns\n\nA NamedTuple with cache statistics:\n\ncache_size: Number of entries in cache\nactive_files: Number of actually open files\ndead_references: Number of garbage-collected references\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_chunked_array-Tuple{JLD2.JLDFile, String}","page":"Internals & Design","title":"JLD2.get_chunked_array","text":"get_chunked_array(f::JLDFile, name::String) -> ChunkedArray\n\nGet a ChunkedArray object for a dataset, allowing iteration over individual chunks.\n\nExample\n\njldopen(\"file.jld2\", \"r\") do f\n    chunked = JLD2.get_chunked_array(f, \"my_dataset\")\n\n    # Iterate over all chunks\n    for chunk in chunked\n        println(\"Chunk at \", chunk.indices, \": \", size(chunk.data))\n    end\n\n    # Or access a specific chunk\n    chunk = chunked[2, 3]  # Get chunk at grid position (2,3)\nend\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_dataset-Tuple{JLD2.JLDFile, Vararg{Any}}","page":"Internals & Design","title":"JLD2.get_dataset","text":"get_dataset(parent::Union{JLDFile, Group}, name::String)\n\nGet a stored dataset from a file by name or path as a Dataset object. This may be useful for inspecting the metadata incl. types of a dataset.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_external_file-Tuple{String, String}","page":"Internals & Design","title":"JLD2.get_external_file","text":"get_external_file(current_file_path::String, external_file_path::String) -> JLDFile\n\nOpen or retrieve a cached external file handle.\n\nArguments\n\ncurrent_file_path: Path to the current file (for resolving relative external paths)\nexternal_file_path: Path to the external file (from the external link)\n\nReturns\n\nAn open JLDFile handle to the external file.\n\nError Handling\n\nThrows appropriate exceptions for various failure modes:\n\nSystemError: File not found or permission denied\nArgumentError: Invalid file format or security violation\nUnsupportedFeatureException: Circular reference detection\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_reference_chain-Tuple{}","page":"Internals & Design","title":"JLD2.get_reference_chain","text":"get_reference_chain() -> Vector{String}\n\nGet the current external file reference chain for this task.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_reference_chain_info-Tuple{}","page":"Internals & Design","title":"JLD2.get_reference_chain_info","text":"get_reference_chain_info() -> NamedTuple\n\nGet information about the current reference chain for debugging.\n\nReturns\n\nA NamedTuple with:\n\nchain_length: Current chain depth\nchain_files: List of files in the current chain\nmax_depth_reached: Whether we're near the maximum allowed depth\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.get_target-Tuple{HardLink}","page":"Internals & Design","title":"JLD2.get_target","text":"get_target(link::HardLink)\n\nExtract the target RelOffset from a hard link. This provides compatibility with existing code that expects RelOffset values.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.group_path-Tuple{JLD2.Group}","page":"Internals & Design","title":"JLD2.group_path","text":"group_path(g::Group) -> String\n\nGet the absolute path of a group within its file.\n\nReturns\n\nThe absolute path of the group within the HDF5 file (e.g., \"/data/measurements\"). For the root group, returns \"/\".\n\nAlgorithm\n\nIf this is the root group, returns \"/\"\nOtherwise, searches through unwrittenchildgroups only (performance optimization)\nFor groups loaded from disk, falls back to \"/\" (limitation of current implementation)\n\nPerformance Note\n\nThis implementation prioritizes performance over complete accuracy. It only searches through in-memory group hierarchies (unwrittenchildgroups) to avoid expensive disk I/O. For complex hierarchies with groups loaded from disk, relative soft links may not resolve perfectly, but absolute soft links will always work.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.h5offset-Tuple{JLD2.JLDFile, Integer}","page":"Internals & Design","title":"JLD2.h5offset","text":"h5offset(f::JLDFile, x::Integer)\n\nConverts an absolute file offset x to an offset relative to the superblock of file f.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.insert_chunk!","page":"Internals & Design","title":"JLD2.insert_chunk!","text":"insert_chunk!(btree::V1BTree, chunk_indices::Vector{Int}, chunk_address::RelOffset,\n             chunk_size::UInt32, filter_mask::UInt32 = 0x00000000)\n\nInsert a chunk into the V1 B-tree, handling node splits and tree growth as needed. This is the main entry point for adding chunks to the tree.\n\nChunks are accumulated in the btree's pendingchunks field and written out when finalizebtree! is called.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.insert_into_node!-Tuple{JLD2.V1BTreeNode, JLD2.V1ChunkKey, JLD2.RelOffset, UInt16}","page":"Internals & Design","title":"JLD2.insert_into_node!","text":"insert_into_node!(node::V1BTreeNode, key::V1ChunkKey, child::RelOffset, max_entries::UInt16)::Bool\n\nInsert a key/child pair into a node if it has capacity. Returns true if insertion succeeded, false if node is full.\n\nMaintains the V1 B-tree ordering invariant for chunked datasets.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.insert_recursive!-Tuple{JLD2.JLDFile, JLD2.RelOffset, JLD2.V1ChunkKey, JLD2.RelOffset, JLD2.V1BTree}","page":"Internals & Design","title":"JLD2.insert_recursive!","text":"insert_recursive!(f::JLDFile, node_offset::RelOffset, key::V1ChunkKey,\n                 child_address::RelOffset, btree::V1BTree)::Tuple{Union{V1ChunkKey, Nothing}, Union{RelOffset, Nothing}}\n\nRecursively insert a key/child pair into the B-tree, handling splits as needed. Returns (promotedkey, promotedchild_offset) if the node was split, (nothing, nothing) otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.is_external_link-Tuple{AbstractLink}","page":"Internals & Design","title":"JLD2.is_external_link","text":"is_external_link(link::AbstractLink)\n\nReturns true if the link is an external link, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.is_hard_link-Tuple{AbstractLink}","page":"Internals & Design","title":"JLD2.is_hard_link","text":"is_hard_link(link::AbstractLink)\n\nReturns true if the link is a hard link, false otherwise. This can be used for performance optimizations where hard links can be handled more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.is_retryable_error-Tuple{Exception}","page":"Internals & Design","title":"JLD2.is_retryable_error","text":"is_retryable_error(error::Exception) -> Bool\n\nDetermine if an error is worth retrying for external file access.\n\nArguments\n\nerror: The exception that occurred\n\nReturns\n\ntrue if the error might be transient and worth retrying, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.is_soft_link-Tuple{AbstractLink}","page":"Internals & Design","title":"JLD2.is_soft_link","text":"is_soft_link(link::AbstractLink)\n\nReturns true if the link is a soft link, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.ismmappable-Tuple{JLD2.Dataset}","page":"Internals & Design","title":"JLD2.ismmappable","text":"ismmappable(dset::Dataset)\n\nCheck if a dataset can be memory-mapped. This can be useful for large arrays and for editing written arrays.\n\nAn Array dataset may be mmapped if:     - JLD2.samelayout(T) == true: The element type is isbits and has a size that either 1, 2, 4, or a multiple of 8 bytes.     - Uncompressed: Compressed arrays cannot be memory-mapped     - Uses a contiguous layout: This is true for all array datasets written by JLD2 with version ≥ v0.4.52     - Windows: The file must be opened in read-only mode. This is a limitation of Mmap on Windows.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.isset-Tuple{Any, Any}","page":"Internals & Design","title":"JLD2.isset","text":"isset(flag, bit)\n\nReturn true if the bit-th bit of flag is set. (starting from 0)   \n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}","page":"Internals & Design","title":"JLD2.jld_finalizer","text":"jld_finalizer(f::JLDFile)\n\nWhen a JLDFile is finalized, it is possible that the MmapIO has been munmapped, since Julia does not guarantee finalizer order. This means that the underlying file may be closed before we get a chance to write to it.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.jldopen","page":"Internals & Design","title":"JLD2.jldopen","text":"jldopen(file, mode::AbstractString; iotype=MmapIO, compress=false, typemap=JLD2.default_typemap)\n\nOpens a JLD2 file at path file. Alternatively file may be a suitable IO object.\n\nOptions for mode:\n\n\"r\": Open for reading only, failing if no file exists\n\"r+\": Open for reading and writing, failing if no file exists\n\"w\"/\"w+\": Open for reading and writing, overwriting the file if it already exists\n\"a\"/\"a+\": Open for reading and writing, creating a new file if none exists, but               preserving the existing file if one is present\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.jldsave","page":"Internals & Design","title":"JLD2.jldsave","text":"jldsave(filename; kwargs...)\njldsave(filename, compress; kwargs...)\njldsave(filename, compress, iotype; kwargs...)\n\nCreates a JLD2 file at filename and stores the variables given as keyword arguments.\n\nExamples\n\njldsave(\"example.jld2\"; a=1, b=2, c)\n\nis equivalent to\n\njldopen(\"example.jld2\", \"w\") do f\n    f[\"a\"] = 1\n    f[\"b\"] = 2\n    f[\"c\"] = c\nend\n\nTo choose the io type IOStream instead of the default MmapIO use  jldsave(fn, IOStream; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.jlwrite-Tuple{IO, Tuple}","page":"Internals & Design","title":"JLD2.jlwrite","text":"jlwrite(io::IO, x::Tuple)\n\nAttempt to write a tuple to io by writing each element of the tuple in order.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.links_size-Tuple{Any}","page":"Internals & Design","title":"JLD2.links_size","text":"links_size(pairs)\n\nReturns the size of several link messages. pairs is an iterator of String => AbstractLink pairs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_attributes","page":"Internals & Design","title":"JLD2.load_attributes","text":"load_attributes(f::JLDFile, name::AbstractString)\nload_attributes(g::Group, name::AbstractString)\nload_attributes(g::Group)\nload_attributes(f::JLDFile, offset::RelOffset)\n\nReturn a list of attributes attached to the dataset or group.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.load_data_or_dict-Tuple{Union{JLD2.Group, JLD2.JLDFile}, AbstractString}","page":"Internals & Design","title":"JLD2.load_data_or_dict","text":"load_data_or_dict(g::Union{JLDFile,Group}, varname::AbstractString)\n\nReturn the value of key varname but if it represents a Group load the group as a nested dictionary.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_datatypes-Tuple{JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.load_datatypes","text":"load_datatypes(f::JLDFile)\n\nPopulate f.datatypes and f.jlh5types with all of the committed datatypes from a file. We need to do this before writing to make sure we reuse written datatypes.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.load_object-Tuple{Any}","page":"Internals & Design","title":"JLD2.load_object","text":"load_object(filename)\n\nReturns the only available object from the JLD2 file filename (The stored object name is inconsequential). If the file contains more than one or no objects, the function throws an ArgumentError.\n\nFor loading more than one object, use @load macro, jldopen or the FileIO API.\n\nExample\n\nTo load the only object from the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\nhello_loaded = load_object(\"example.jld2\")\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.loadnesteddict-Tuple{Union{JLD2.Group, JLD2.JLDFile}}","page":"Internals & Design","title":"JLD2.loadnesteddict","text":"loadnesteddict(g::Union{JLDFile, Group})\n\nReturn a dictionary with all data contained in group or file. Nested groups are loaded as nested dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.lookup_link-Tuple{JLD2.Group, AbstractString}","page":"Internals & Design","title":"JLD2.lookup_link","text":"lookup_link(g::Group, name::AbstractString) -> Union{AbstractLink, Nothing}\n\nLookup a link in a group by name. Returns the AbstractLink object if found, or nothing if not present. This function supports all link types (hard, soft, external).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.manage_cache_size-Tuple{}","page":"Internals & Design","title":"JLD2.manage_cache_size","text":"manage_cache_size()\n\nKeep the external file cache size under control by removing least recently used entries.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.message_size_for_link-Tuple{String, AbstractLink}","page":"Internals & Design","title":"JLD2.message_size_for_link","text":"message_size_for_link(name::String, link::AbstractLink) -> Int\n\nCalculate the size of a link message for the given link type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.navigate_external_path-Tuple{JLD2.JLDFile, String}","page":"Internals & Design","title":"JLD2.navigate_external_path","text":"navigate_external_path(external_file::JLDFile, object_path::String) -> Any\n\nNavigate through an object path within an external file to find the target object.\n\nArguments\n\nexternal_file: The external JLD2 file\nobject_path: Path within the file (without leading slash)\n\nReturns\n\nThe object at the specified path.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.normalize_hdf5_path-Tuple{String}","page":"Internals & Design","title":"JLD2.normalize_hdf5_path","text":"normalize_hdf5_path(path::String) -> String\n\nNormalize an HDF5 path to standard format.\n\nRules\n\nEnsures path starts with '/' (absolute)\nNormalizes path separators to '/'\nRemoves redundant components like \"//\" or \"/./\"\nHandles \"..\" components properly\n\nExamples\n\nnormalize_hdf5_path(\"/data//measurements/./temp\") # => \"/data/measurements/temp\"\nnormalize_hdf5_path(\"data/measurements\") # => \"/data/measurements\"\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.num_chunks-Union{Tuple{ChunkedArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Internals & Design","title":"JLD2.num_chunks","text":"num_chunks(ca::ChunkedArray) -> Int\n\nGet the total number of chunks in the array.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.open_external_file_with_retry-Tuple{String}","page":"Internals & Design","title":"JLD2.open_external_file_with_retry","text":"open_external_file_with_retry(file_path::String) -> JLDFile\n\nOpen an external file with retry logic for transient failures.\n\nArguments\n\nfile_path: Path to the external file to open\n\nReturns\n\nAn open JLDFile handle.\n\nError Handling\n\nImplements exponential backoff retry logic for transient network and I/O failures. Distinguishes between permanent failures (file not found) and transient failures (network timeouts).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.parse_link_message-Tuple{JLD2.HmWrap{JLD2.HmLinkMessage}}","page":"Internals & Design","title":"JLD2.parse_link_message","text":"parse_link_message(wmsg::HmWrap{HmLinkMessage}) -> AbstractLink\n\nParse a link message from the HDF5 format and return the appropriate AbstractLink subtype. Handles hard links (type 0), soft links (type 1), and external links (type 64).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.pathize-Tuple{JLD2.Group, AbstractString, Bool}","page":"Internals & Design","title":"JLD2.pathize","text":"pathize(g::Group, name::AbstractString, create::Bool) -> Tuple{Group,String}\n\nConverts a path to a group and name object. If create is true, any intermediate groups will be created, and the dataset name will be checked for uniqueness with existing names.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.pop_reference_chain!-Tuple{}","page":"Internals & Design","title":"JLD2.pop_reference_chain!","text":"pop_reference_chain!()\n\nRemove the last file from the reference chain.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.prewrite-Tuple{JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.prewrite","text":"prewrite(f::JLDFile)\n\nCheck that a JLD file is actually writable, and throw an error if not. Sets the written flag on the file.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.print_header_messages-Tuple{JLD2.JLDFile, AbstractString}","page":"Internals & Design","title":"JLD2.print_header_messages","text":"print_header_messages(f::JLDFile, name::AbstractString)\nprint_header_messages(g::Group, name::AbstractString)\nprint_header_messages(f::JLDFile, offset::RelOffset)\n\nPrints the header messages of a group or dataset in a file.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.print_raw_bytes-Tuple{JLD2.JLDFile, JLD2.RelOffset, Int64}","page":"Internals & Design","title":"JLD2.print_raw_bytes","text":"print_raw_bytes(f::JLDFile, offset::RelOffset, count::Int)\n\nPrint raw bytes at the given offset for debugging.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.print_raw_bytes_at_position-Tuple{JLD2.JLDFile, Int64, Int64}","page":"Internals & Design","title":"JLD2.print_raw_bytes_at_position","text":"print_raw_bytes_at_position(f::JLDFile, pos::Int, count::Int)\n\nPrint raw bytes at the current file position for debugging.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.print_v1btree-Tuple{JLD2.JLDFile, JLD2.RelOffset, UInt8}","page":"Internals & Design","title":"JLD2.print_v1btree","text":"print_v1btree(f::JLDFile, offset::RelOffset, dimensionality::UInt8)\n\nPretty print the V1 B-tree structure starting at the given offset. This function mimics the output format of h5debug for comparison. Uses granular reading approach that prints information as it's read.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.print_v1btree_node-Tuple{JLD2.V1BTreeNode, JLD2.RelOffset, UInt8}","page":"Internals & Design","title":"JLD2.print_v1btree_node","text":"print_v1btree_node(node::V1BTreeNode, offset::RelOffset, dimensionality::UInt8)\n\nPretty print a single V1 B-tree node in h5debug style.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.printtoc-Tuple{JLD2.JLDFile}","page":"Internals & Design","title":"JLD2.printtoc","text":"printtoc([io::IO,] f::JLDFile [; numlines])\n\nPrints an overview of the contents of f to the IO.\n\nUse the optional numlines parameter to restrict the amount of items listed.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.push_reference_chain!-Tuple{String}","page":"Internals & Design","title":"JLD2.push_reference_chain!","text":"push_reference_chain!(file_path::String)\n\nAdd a file to the reference chain and return the updated chain.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_array!","page":"Internals & Design","title":"JLD2.read_array!","text":"read_array!(v::Array, f::JLDFile, rr)\n\nFill the array v with the contents of JLDFile f at the current position, assuming a ReadRepresentation rr.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute, JLD2.H5Datatype, JLD2.ReadRepresentation}","page":"Internals & Design","title":"JLD2.read_attr_data","text":"read_attr_data(f::JLDFile, attr::ReadAttribute, expected_datatype::H5Datatype,\n               rr::ReadRepresentation)\n\njlread data from an attribute, assuming a specific HDF5 datatype and ReadRepresentation. If the HDF5 datatype does not match, throws an UnsupportedFeatureException. This allows better type stability while simultaneously validating the data.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute}","page":"Internals & Design","title":"JLD2.read_attr_data","text":"read_attr_data(f::JLDFile, attr::ReadAttribute)\n\njlread data from an attribute.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_chunk_key_debug-Tuple{IO, UInt8}","page":"Internals & Design","title":"JLD2.read_chunk_key_debug","text":"read_chunk_key_debug(io::IO, dimensionality::UInt8)\n\nRead a chunk key with debug information.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_chunk_with_filters!-Tuple{Array, JLD2.JLDFile, Any, Int64, JLD2.Filters.FilterPipeline, Int64}","page":"Internals & Design","title":"JLD2.read_chunk_with_filters!","text":"read_chunk_with_filters!(vchunk::Array, f::JLDFile, rr, chunk_size::Int,\n                        filters::FilterPipeline, filter_mask::Int)\n\nRead chunk data from the current position in f, applying decompression based on filters and filter_mask. The filter_mask indicates which filters were skipped during compression (bit n set = filter n was skipped).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_chunked_array-Union{Tuple{T}, Tuple{JLD2.JLDFile, Array{T}, JLD2.ReadDataspace, JLD2.ReadRepresentation, JLD2.DataLayout, JLD2.Filters.FilterPipeline, JLD2.RelOffset, Int64}} where T","page":"Internals & Design","title":"JLD2.read_chunked_array","text":"read_chunked_array(f::JLDFile, v::Array, dataspace::ReadDataspace,\n                  rr::ReadRepresentation, layout::DataLayout,\n                  filters::FilterPipeline, header_offset::RelOffset,\n                  ndims::Int)\n\nRead a chunked dataset from file into the preallocated array v. Handles V1 B-tree chunked storage with optional compression filters.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_compressed_array!","page":"Internals & Design","title":"JLD2.read_compressed_array!","text":"read_compressed_array!(v::Array, f::JLDFile, rr, data_length::Int, Val(filter_id))\n\nFill the array v with the compressed contents of JLDFile f at the current position, assuming a ReadRepresentation rr and that the compressed data has length data_length.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_data","page":"Internals & Design","title":"JLD2.read_data","text":"read_data(f::JLDFile, dataspace::ReadDataspace, datatype_class::UInt8,\n          datatype_offset::Int64, data_offset::Int64[, filters::FilterPipeline,\n          header_offset::RelOffset, attributes::Vector{ReadAttribute}])\n\nRead data from a file. If datatype_class is typemax(UInt8), the datatype is assumed to be committed, and datatype_offset points to the offset of the committed datatype's header. Otherwise, datatype_offset points to the offset of the datatype attribute.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_dataset-Tuple{JLD2.Dataset}","page":"Internals & Design","title":"JLD2.read_dataset","text":"read_dataset(dset::Dataset)\n\nRead the data referenced by a dataset.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_first_key_from_node-Tuple{JLD2.JLDFile, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.read_first_key_from_node","text":"read_first_key_from_node(file::JLDFile, node_offset::RelOffset)::V1ChunkKey\n\nRead the first key from a B-tree node (used for building internal nodes).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_last_key_from_node-Tuple{JLD2.JLDFile, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.read_last_key_from_node","text":"read_last_key_from_node(file::JLDFile, node_offset::RelOffset)::V1ChunkKey\n\nRead the last key from a B-tree node (used for boundary keys in internal nodes).\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_scalar","page":"Internals & Design","title":"JLD2.read_scalar","text":"read_scalar(f::JLDFile, rr, header_offset::RelOffset)\n\nRead raw data representing a scalar with read representation rr from the current position of JLDFile f. header_offset is the RelOffset of the object header, used to resolve cycles.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.read_size-Tuple{IO, UInt8}","page":"Internals & Design","title":"JLD2.read_size","text":"read_size(io::IO, flags::UInt8)\n\nLoads a variable-length size according to flags\n\nExpects that the first two bits of flags mean:\n\n0:   The size of the Length of Link Name field is 1 byte.\n1:   The size of the Length of Link Name field is 2 bytes.\n2:   The size of the Length of Link Name field is 4 bytes.\n3:   The size of the Length of Link Name field is 8 bytes.\n\nReturns the size as an Int.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_v1btree_node-Tuple{JLD2.JLDFile, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.read_v1btree_node","text":"read_v1btree_node(f::JLDFile, offset::RelOffset)::V1BTreeNode\n\nRead a V1 B-tree node from file at the given offset. This is a wrapper around the existing reading functionality to create our mutable struct.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.read_v1btree_node_debug-Tuple{JLD2.JLDFile, JLD2.RelOffset, UInt8}","page":"Internals & Design","title":"JLD2.read_v1btree_node_debug","text":"read_v1btree_node_debug(f::JLDFile, offset::RelOffset, dimensionality::UInt8)\n\nRead a V1 B-tree node with detailed error handling for debugging.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.readas-Tuple{Any}","page":"Internals & Design","title":"JLD2.readas","text":"readas(::Type)::Type\n\nExperimental feature:  JLD2.readas can be overloaded to override which type a saved type is read as, and is used together with custom serialization using JLD2.writeas.\n\nThe typical case is custom serialization of parametric types, where not all type parameters are available during reading.  Consider the following example for an anonymous function fun inside a Foo\n\nstruct Foo{F<:Function}\n    fun::F\nend\nstruct FooSerialization\n    fun\nend\nJLD2.writeas(::Type{<:Foo}) = FooSerialization\nBase.convert(::Type{<:FooSerialization}, f::Foo) = FooSerialization(f.fun)\n\nJLD2.readas(::Type{<:FooSerialization}) = Foo\nstruct UndefinedFunction <:Function\n    fun\nend\n(f::UndefinedFunction)(args...; kwargs...) = error(\"The function $(f.fun) is not defined\")\nfunction Base.convert(::Type{<:Foo}, f::FooSerialization)\n    isa(f.fun, Function) && return Foo(f.fun)\n    return Foo(UndefinedFunction(f.fun))\nend\n\nIf we include these definitions, call jldsave(\"foo.jld2\"; foo=Foo(x->x^2)), restart julia, include the definitions again, and call foo = jldopen(\"foo.jld2\") do io; io[\"foo\"]; end, we get foo::Foo{UndefinedFunction} and foo::FooSerialization with and without defining the JLD2.readas above, respectively.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.readmmap-Tuple{JLD2.Dataset}","page":"Internals & Design","title":"JLD2.readmmap","text":"readmmap(dset::Dataset)\n\nMemory-map a dataset. This can be useful for large arrays and for editing written arrays. See ismmappable for requirements.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.requires_resolution-Tuple{AbstractLink}","page":"Internals & Design","title":"JLD2.requires_resolution","text":"requires_resolution(link::AbstractLink)\n\nReturns true if the link requires resolution (soft or external links), false for hard links that can be accessed directly.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.resolve_external_file_path-Tuple{String, String}","page":"Internals & Design","title":"JLD2.resolve_external_file_path","text":"resolve_external_file_path(current_file_path::String, external_file_path::String) -> String\n\nResolve an external file path relative to the current file's directory.\n\nArguments\n\ncurrent_file_path: Path to the current JLD2 file (used as reference for relative paths)\nexternal_file_path: The external file path from the external link (may be relative or absolute)\n\nReturns\n\nThe resolved absolute path to the external file.\n\nPath Processing\n\nNormalizes path separators for cross-platform compatibility\nResolves relative paths relative to the current file's directory\n\nExamples\n\n# Relative external file path\ncurrent = \"/home/user/data/main.jld2\"\nexternal = \"./external_data.jld2\"\nresolved = resolve_external_file_path(current, external)\n# Result: \"/home/user/data/external_data.jld2\"\n\n# Absolute external file path\ncurrent = \"/home/user/data/main.jld2\"\nexternal = \"/shared/datasets/public.jld2\"\nresolved = resolve_external_file_path(current, external)\n# Result: \"/shared/datasets/public.jld2\"\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.resolve_external_link-Tuple{JLD2.JLDFile, ExternalLink}","page":"Internals & Design","title":"JLD2.resolve_external_link","text":"resolve_external_link(current_file::JLDFile, external_link::ExternalLink) -> Union{Any, Nothing}\n\nResolve an external link and return the target object.\n\nArguments\n\ncurrent_file: The current JLD2 file containing the external link\nexternal_link: The external link to resolve\n\nReturns\n\nThe object referenced by the external link, or throws an exception if resolution fails.\n\nError Handling\n\nFile access errors (not found, permission denied) are passed through as SystemError\nInvalid object paths throw KeyError\nSecurity violations throw ArgumentError\nCircular references throw UnsupportedFeatureException\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.resolve_relative_soft_link-Tuple{JLD2.Group, String}","page":"Internals & Design","title":"JLD2.resolve_relative_soft_link","text":"resolve_relative_soft_link(g::Group, relative_path::String)\n\nResolve a relative soft link path from the current group.\n\nSupported Relative Paths\n\nSimple relative paths without \"..\" (e.g., \"temp\", \"subgroup/data\")\nPaths with \"..\" components have limited support when groups are loaded from disk\n\nAlgorithm\n\nFor simple paths, navigates directly from the current group. For complex paths with \"..\", attempts to use group hierarchy but may fall back to error.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.resolve_soft_link_path-Tuple{String, String}","page":"Internals & Design","title":"JLD2.resolve_soft_link_path","text":"resolve_soft_link_path(group_path::String, soft_link_path::String) -> String\n\nResolve a soft link path within the same HDF5 file.\n\nArguments\n\ngroup_path: Current group's absolute path within the HDF5 file (e.g., \"/data/measurements\")\nsoft_link_path: The soft link target path (may be absolute or relative)\n\nReturns\n\nThe resolved absolute path within the HDF5 file.\n\nPath Resolution Rules\n\nAbsolute paths (starting with '/') are used as-is\nRelative paths are resolved relative to the containing group\nPath separators are normalized to '/' for HDF5 compatibility\n\"..\" components navigate up the group hierarchy\n\nExamples\n\n# Absolute soft link\ngroup_path = \"/data/measurements\"\nsoft_path = \"/results/analysis\"\nresolved = resolve_soft_link_path(group_path, soft_path)\n# Result: \"/results/analysis\"\n\n# Relative soft link\ngroup_path = \"/data/measurements\"\nsoft_path = \"../calibration/offset\"\nresolved = resolve_soft_link_path(group_path, soft_path)\n# Result: \"/data/calibration/offset\"\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.rethrow_with_context-Tuple{Exception, String, String}","page":"Internals & Design","title":"JLD2.rethrow_with_context","text":"rethrow_with_context(error::Exception, resolved_path::String, current_file_path::String)\n\nRethrow an error with enhanced context information for debugging.\n\nArguments\n\nerror: The original exception\nresolved_path: The resolved external file path\ncurrent_file_path: The current file path for context\n\nError Enhancement\n\nPreserves the original error type while adding helpful context information.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.save_group-Tuple{JLD2.Group}","page":"Internals & Design","title":"JLD2.save_group","text":"save_group(g::Group) -> RelOffset\n\nStores a group to a file, updating it if it has already been saved. Returns UNDEFINED_ADDRESS if the group was already stored, or the offset of the new group otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.save_object-Tuple{Any, Any}","page":"Internals & Design","title":"JLD2.save_object","text":"save_object(filename, x)\n\nStores an object x in a new JLD2 file at filename. If a file exists at this path, it will be overwritten.\n\nSince the JLD2 format requires that all objects have a name, the object will be stored as single_stored_object. If you want to store more than one object, use @save macro, jldopen or the FileIO API.\n\nExample\n\nTo save the string hello to the JLD2 file example.jld2:\n\nhello = \"world\"\nsave_object(\"example.jld2\", hello)\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.set_reference_chain-Tuple{Vector{String}}","page":"Internals & Design","title":"JLD2.set_reference_chain","text":"set_reference_chain(chain::Vector{String})\n\nSet the external file reference chain for this task.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.shorttypestring-Tuple{Any}","page":"Internals & Design","title":"JLD2.shorttypestring","text":"shorttypestring(::Type{ <:UnknownType})\n\nConvert an UnknownType to a corresponding string. This is only used to create names for reconstructed types.\n\nSee also typestring.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.size_flag-Tuple{Integer}","page":"Internals & Design","title":"JLD2.size_flag","text":"size_flag(sz::Integer)::UInt8\n\nReturn the flag that represents the smallest integer type that can represent sz. 0 -> UInt8, 1 -> UInt16, 2 -> UInt32, 3 -> UInt64\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.size_size-Tuple{Integer}","page":"Internals & Design","title":"JLD2.size_size","text":"size_size(sz::Integer)\n\nReturn the number of bytes required to represent sz as an unsigned integer that actually exists. (e.g. UInt8, UInt16, UInt32, UInt64)\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.size_size2-Tuple{Integer}","page":"Internals & Design","title":"JLD2.size_size2","text":"size_size2(sz::Integer)\n\nReturn the number of bytes required to represent sz as an unsigned integer. Note: this does not check if the integer is a valid julia integer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.skip_to_aligned!","page":"Internals & Design","title":"JLD2.skip_to_aligned!","text":"skip_to_aligned!(io, rel=0)\n\nSkip to nearest position aligned to a multiple of 8 bytes relative to rel.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.split_into_leaf_nodes-Tuple{JLD2.JLDFile, Vector{JLD2.V1ChunkKey}, Vector{JLD2.RelOffset}, UInt16}","page":"Internals & Design","title":"JLD2.split_into_leaf_nodes","text":"split_into_leaf_nodes(file::JLDFile, keys::Vector{V1ChunkKey}, children::Vector{RelOffset}, max_entries::UInt16)\n\nSplit chunks into multiple leaf nodes, each containing at most max_entries chunks. Returns a vector of leaf node offsets.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.split_node-Tuple{JLD2.JLDFile, JLD2.V1BTreeNode, JLD2.V1BTree}","page":"Internals & Design","title":"JLD2.split_node","text":"split_node(f::JLDFile, node::V1BTreeNode, btree::V1BTree)::Tuple{V1BTreeNode, V1BTreeNode, V1ChunkKey, RelOffset}\n\nSplit a full node roughly in half and return the left node, right node, promoted key, and the right node's file offset.\n\nUpdates sibling pointers and writes both nodes to file. Returns tuple: (leftnode, rightnode, promotedkey, rightoffset)\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.split_null_terminated_strings","page":"Internals & Design","title":"JLD2.split_null_terminated_strings","text":"split_null_terminated_strings(blob::Vector{UInt8}) -> Vector{String}\n\nSplit a byte blob containing null-terminated strings into separate string components. Used for parsing external link information.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.symbol_length-Tuple{Symbol}","page":"Internals & Design","title":"JLD2.symbol_length","text":"symbol_length(x::Symbol)\n\nReturns the length of the string represented by x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.typestring-Tuple{Any}","page":"Internals & Design","title":"JLD2.typestring","text":"typestring(::Type{ <:UnknownType})\n\nConvert an UnknownType to a corresponding string. This is only used for warning during reconstruction errors.\n\nSee also shorttypestring.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.uintofsize-Tuple{Any}","page":"Internals & Design","title":"JLD2.uintofsize","text":"uintofsize(sz::Integer)\n\nReturn the UInt type that has sz bytes.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.update_sibling_pointer-Tuple{JLD2.JLDFile, JLD2.RelOffset, Symbol, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.update_sibling_pointer","text":"update_sibling_pointer(f::JLDFile, node_offset::RelOffset, side::Symbol, new_offset::RelOffset)\n\nUpdate the left or right sibling pointer of a node at the given offset. Used during node splits to maintain doubly-linked sibling lists.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.validate_external_link_paths-Tuple{String, String}","page":"Internals & Design","title":"JLD2.validate_external_link_paths","text":"validate_external_link_paths(file_path::String, object_path::String)\n\nValidate external link paths. Returns normalized paths or throws ArgumentError if invalid.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.validate_soft_link_path-Tuple{String}","page":"Internals & Design","title":"JLD2.validate_soft_link_path","text":"validate_soft_link_path(path::String)\n\nValidate a soft link path. Throws ArgumentError if invalid.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_chunk_key-Tuple{IO, JLD2.V1ChunkKey}","page":"Internals & Design","title":"JLD2.write_chunk_key","text":"write_chunk_key(io::IO, key::V1ChunkKey)\n\nWrite a V1 chunk key to the given IO stream.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_chunked_dataset_with_v1btree-Tuple{JLD2.JLDFile, Any, Any, Any, JLD2.JLDWriteSession, Vector{Int64}}","page":"Internals & Design","title":"JLD2.write_chunked_dataset_with_v1btree","text":"write_chunked_dataset_with_v1btree(f::JLDFile, data, dataspace, datatype, chunk_dims::Vector{Int})\n\nWrite a chunked dataset using V1 B-tree indexing. This is the main integration function that replaces simple compression with proper chunking.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_dataset","page":"Internals & Design","title":"JLD2.write_dataset","text":"write_dataset(dataset::Dataset, data)\n\nWrite data to file using metadata prepared in the dataset.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JLD2.write_link_message-Tuple{Any, String, AbstractLink}","page":"Internals & Design","title":"JLD2.write_link_message","text":"write_link_message(io, name::String, link::AbstractLink)\n\nWrite a link message for the given link type to the I/O stream.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_size-Tuple{IO, Integer}","page":"Internals & Design","title":"JLD2.write_size","text":"write_size(io::IO, sz::Integer)\n\nWrite the mininum number of bytes required to represent sz as (valid) unsigned integer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_v1btree_node-Tuple{JLD2.JLDFile, JLD2.V1BTreeNode}","page":"Internals & Design","title":"JLD2.write_v1btree_node","text":"write_v1btree_node(f::JLDFile, node::V1BTreeNode)::RelOffset\n\nWrite a V1 B-tree node to file and return its offset. Allocates space at the end of the file for the node.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_v1btree_node_at_offset-Tuple{JLD2.JLDFile, JLD2.V1BTreeNode, JLD2.RelOffset}","page":"Internals & Design","title":"JLD2.write_v1btree_node_at_offset","text":"write_v1btree_node_at_offset(f::JLDFile, node::V1BTreeNode, offset::RelOffset)\n\nWrite a V1 B-tree node to file at a specific offset. Used when updating existing nodes.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.write_zerobytes-Tuple{Any, Any}","page":"Internals & Design","title":"JLD2.write_zerobytes","text":"write_zerobytes(io, n)\n\nWrite n zero bytes to io.\n\n\n\n\n\n","category":"method"},{"location":"internals/#JLD2.@load-Tuple{Any, Vararg{Any}}","page":"Internals & Design","title":"JLD2.@load","text":"@load filename var1 [var2 ...]\n\nLoad one or more variables var1,... from JLD2 file filename into the current scope and return a vector of the loaded variable names.\n\nFor interactive use, the form @load \"somefile.jld2\" will load all variables from \"somefile.jld2\" into the current scope. This form only supports literal file names and should be avoided in more permanent code so that it's clear where the variables come from.\n\nExample\n\nTo load the variables hello and foo from the file example.jld2, use\n\n@load \"example.jld2\" hello foo\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JLD2.@pseudostruct-Tuple{Any, Any}","page":"Internals & Design","title":"JLD2.@pseudostruct","text":"@pseudostruct name begin ... end\n\nThe @pseudostruct macro is used to define constructor, size computation, show, and and optimized getproperty function for Messages. The allowed syntax elements are:\n\n@skip(n): Mark n bytes as empty.\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JLD2.@save-Tuple{Any, Vararg{Any}}","page":"Internals & Design","title":"JLD2.@save","text":"@save filename var1 [var2 ...]\n@save filename {compress=true} var1 name2=var2\n\nWrite one or more variables var1,... from the current scope to a JLD2 file filename.\n\nFor interactive use you can save all variables in the current module's global scope using @save filename. More permanent code should prefer the explicit form to avoid saving unwanted variables.\n\nExample\n\nTo save the string hello and array xs to the JLD2 file example.jld2:\n\nhello = \"world\"\nxs = [1,2,3]\n@save \"example.jld2\" hello xs\n\nFor passing options to the saving command use {}\n\n@save \"example.jld2\" {compress=true} hello xs\n\nFor saving variables under a different name use regular assignment syntax\n\n@save \"example.jld2\" greeting=hello xarray = xs\n\n\n\n\n\n","category":"macro"},{"location":"troubleshooting/#Gotchas-and-Troubleshooting","page":"Troubleshooting","title":"Gotchas & Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Objects-are-cached-during-loading","page":"Troubleshooting","title":"Objects are cached during loading","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"JLD2 caches objects during loading. It may give you the same object twice. This can lead to surprising results if you edit loaded arrays. Note, the underlying file is not being edited!","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using JLD2 #hide\njldsave(\"demo.jld2\", a=zeros(2))\nf = jldopen(\"demo.jld2\")\na = f[\"a\"] # bind loaded array to name `a`\na[1] = 42; # editing the underlying array\nf[\"a\"]\na = nothing # remove all references to the loaded array\nGC.gc(true) # call GC to remove the cache\nf[\"a\"] # a new copy is loaded from the file\nclose(f) #hide","category":"page"},{"location":"troubleshooting/#Cross-compatibility","page":"Troubleshooting","title":"Cross-compatibility","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"JLD2 tries to write files in a way that allows you to load them on different operating systems and in particular both on 32bit and 64bit systems. However, many julia structs may be inherently different on different architectures making this task impossible. In particular, moving data from a 64bit system to a 32bit system is only guaranteed to work for basic datatypes.","category":"page"},{"location":"troubleshooting/#Security","page":"Troubleshooting","title":"Security","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Beware of opening JLD2 files from untrusted sources. A malicious file may execute code on your computer. See e.g. this project's issue #117. To check a file, you can use debug tooling provided by JLD2 to view what kinds of objects are stored. Details on the available tools are described below.","category":"page"},{"location":"troubleshooting/#Viewing-header-messages","page":"Troubleshooting","title":"Viewing header messages","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Following the HDF5 format specification, JLD2 stores metadata and all information required to interpret the stored data for each dataset in the form of so-called header messages. Each hdf5 group, dataset, and committed datatype consist of and object header followed by a variable number of header messages.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"There exist different types of these to encode for the data type or the layout i.e. single element or array.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"These can be printed for inspection using JLD2:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using JLD2 #hide\njldsave(\"test.jld2\";\n    a = 42,\n    b = [1,2,3,4,5],\n    c = (1,2),\n)\nf = jldopen(\"test.jld2\")\nJLD2.print_header_messages(f, \"a\")","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here we see, among other things, a","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"dataspace message which states that \"a\" is a single (scalar) element\ndatatype message\ndatalayout message of the compact type which means that the data is so small it was","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"directly stored as part of the message.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"JLD2.print_header_messages(f, \"b\")","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Important differences to \"a\" are that the dataspace now reports the dimensions of the array as (5,) and the the data layout has changed to contiguous which means that it is stored as a single block starting at the offset reported in data_address.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"JLD2.print_header_messages(f, \"c\")","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"For dataset c we see that the datatype is a shared datatype which is stored elsewhere in the file and is referenced by its offset. This is, of course, also a regular hdf5 object and we can print its header messages by supplying the offset:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"JLD2.print_header_messages(f, JLD2.RelOffset(4520))\nclose(f) #hide","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This object consists of just two messages:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The datatype message defines the hdf5 datatype and therefore describes the byte layout","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"and field types.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The attribute message has the name julia_type and as payload the julia DataType","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"signature Tuple{Int64, Int64} which is needed for reconstruction.","category":"page"},{"location":"customserialization/#Custom-Serialization","page":"Custom Serialization","title":"Custom Serialization","text":"","category":"section"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"JLD2 makes it easy to define custom serialization for your own types. To do this, define a new type (e.g. ASerialization) that contains the fields you want to store, and then tell JLD2 how to convert between your type and the serialization type.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"For example:","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"struct A\n    x::Int\nend\n\nstruct ASerialization\n    x::Vector{Int}\nend\n\nJLD2.writeas(::Type{A}) = ASerialization\nBase.convert(::Type{ASerialization}, a::A) = ASerialization([a.x])\nBase.convert(::Type{A}, a::ASerialization) = A(only(a.x))","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"JLD2 will automatically use these conversions when saving and loading objects of type A.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"warning: Already defined custom serialization\nSome Julia built-in types already use custom serialization, and JLD2 cannot nest these. To avoid unexpected behavior, always define a wrapper type for your serialization (as in the example above, where ASerialization is used instead of a plain Vector{Int}). In particular, avoid using built-in types like <: AbstractDict or <: Array directly as your serialization type.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"If you prefer not to overload Base.convert, you can instead define the following methods:","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"JLD2.wconvert(::Type{ASerialization}, a::A) = ASerialization([a.x])\nJLD2.rconvert(::Type{A}, a::ASerialization) = A(only(a.x))","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"This approach is especially useful if you do not own the type you want to serialize, or want to avoid extending Base.","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"Here's another example:","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"struct B\n    x::Float64\nend\n\nJLD2.writeas(::Type{B}) = Float64\nJLD2.wconvert(::Type{Float64}, b::B) = b.x\nJLD2.rconvert(::Type{B}, x::Float64) = B(x)\n\narr = [B(rand()) for i in 1:10]\n\n@save \"test.jld2\" arr","category":"page"},{"location":"customserialization/","page":"Custom Serialization","title":"Custom Serialization","text":"In this example, JLD2 converts the array of B structs to a plain Vector{Float64} before storing it to disk.","category":"page"},{"location":"#Welcome-to-**JLD2.jl**","page":"Home","title":"Welcome to JLD2.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JLD2.jl is a high-performance, pure Julia library for saving and loading arbitrary Julia data structures. It's designed as a fast binary serialization format that produces files according to the well-known HDF5 format but doesn't rely on external libraries like the HDF5 C-library — making it an ideal choice for native Julia workflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#What-is-JLD2.jl?","page":"Home","title":"📦 What is JLD2.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JLD2 stands for Julia Data Format 2, a file format and serialization library tailored to work seamlessly with native Julia types. Whether you're working with arrays, dictionaries, structs, or custom types, JLD2 provides a reliable way to store your data to disk and retrieve it later — all in pure Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Why-Use-JLD2?","page":"Home","title":"🚀 Why Use JLD2?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"✅ Save and load any Julia type, including custom structs\n✅ Fast and efficient, thanks to native Julia code\n✅ Custom IO support — can read and write to either Vector{UInt8} or custom IO implementations\n✅ Portable within Julia versions — great for caching, prototyping, and long-term storage\n✅ Customizable type loading — offers fine-grained control to update outdated stored structures upon load","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Example:-Saving-and-Loading-Data","page":"Home","title":"✨ Example: Saving and Loading Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JLD2\n\n# Some sample data\nmodel = (name = \"Transformer\", layers = 12, params = 300_000_000)\nscores = [0.91, 0.87, 0.93]\n\n# Save to a file\n@save \"model_state.jld2\" model scores\n\n# Load back later\n@load \"model_state.jld2\" model scores\n\nprintln(model.name)  # Output: Transformer","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also save individual variables or load just what you need:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@save \"data.jld2\" a=1 b=[1,2,3] c=\"hi\"\n@load \"data.jld2\" b c","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Related-Serialization-libraries-in-Julia","page":"Home","title":"📊 Related Serialization libraries in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below is a comparison of JLD2 and other common Julia libraries for data storage and serialization. Choose the tool that best fits your needs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Library Best For Notes\nJLD2.jl Native Julia data (structs, arrays, Dicts, etc.) Fast, flexible, pure Julia, HDF5-compatible, no external dependencies\nSerialization.jl Any Julia object Built-in, very fast, but not cross-version safe or portable outside Julia\nMAT.jl Interop with MATLAB .mat files Read/write MATLAB files, good for sharing with MATLAB users\nHDF5.jl Full-featured HDF5 access Direct interface to HDF5 C library, cross-language, supports advanced HDF5 features\nArrow.jl Tabular data, dataframes, analytics Excellent for columnar data, cross-language (Python, R, etc.), DataFrame support\nCSV.jl Lightweight table exports/imports Great for human-readable, row-based data, simple and widely supported\nJSON.jl Web services, config files, nested dicts Portable, text-based, less efficient for complex Julia types","category":"page"},{"location":"","page":"Home","title":"Home","text":"If your goal is to store structured tables (like DataFrames) for analysis or sharing between tools, Arrow.jl or CSV.jl may be a better fit. But if you're dealing with rich, nested, Julia-native data, or just want a fast way to persist your models, simulations, or internal state, JLD2 is the right tool.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Contributing","page":"Home","title":"💬 Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JLD2 is community-driven! We welcome contributions, bug reports, and suggestions at the GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're interested in improving documentation, fixing issues, or proposing new features, we’d love your help.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Next-Steps","page":"Home","title":"🧭 Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use the sidebar to navigate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Usage Guide\nCustom serialization\nCompression\nAdvanced Tips\nHDF5 compatibility\nGotchas & Troubleshooting","category":"page"},{"location":"external_links/#External-Links-and-Soft-Links-in-JLD2","page":"Dataset Links","title":"External Links and Soft Links in JLD2","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"JLD2 now supports external links and soft links, enabling cross-file references and flexible file organization patterns. This feature is fully compatible with the HDF5 specification and standard HDF5 tools.","category":"page"},{"location":"external_links/#Overview","page":"Dataset Links","title":"Overview","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"JLD2 supports three types of links:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Hard Links (default): Direct pointers to objects within the same file\nSoft Links: Path-based references resolved at access time within the same file\nExternal Links: References to objects in different HDF5/JLD2 files","category":"page"},{"location":"external_links/#Quick-Start","page":"Dataset Links","title":"Quick Start","text":"","category":"section"},{"location":"external_links/#Creating-External-Links","page":"Dataset Links","title":"Creating External Links","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"using JLD2\n\n# Create an external data file\njldsave(\"data.jld2\";\n        temperature=[23.5, 24.1, 22.8, 25.3],\n        pressure=[1013.2, 1012.8, 1014.1, 1013.5])\n\n# Create main file with external link\njldopen(\"main.jld2\", \"w\") do f\n    f[\"local_data\"] = [1, 2, 3, 4, 5]\n\n    # Create external links\n    create_external_link!(f, \"external_temp\", \"data.jld2\", \"/temperature\")\n    create_external_link!(f, \"external_pressure\", \"data.jld2\", \"/pressure\")\nend\n\n# Access external data transparently\njldopen(\"main.jld2\", \"r\") do f\n    local_data = f[\"local_data\"]           # [1, 2, 3, 4, 5]\n    external_temp = f[\"external_temp\"]     # [23.5, 24.1, 22.8, 25.3]\n    external_press = f[\"external_pressure\"] # [1013.2, 1012.8, 1014.1, 1013.5]\nend","category":"page"},{"location":"external_links/#Creating-Soft-Links","page":"Dataset Links","title":"Creating Soft Links","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"jldopen(\"example.jld2\", \"w\") do f\n    # Create data and groups\n    f[\"dataset1\"] = [1, 2, 3, 4, 5]\n    group = JLD2.Group(f, \"analysis\")\n    group[\"results\"] = [10, 20, 30]\n\n    # Create soft links\n    create_soft_link!(f, \"data_alias\", \"/dataset1\")\n    create_soft_link!(f, \"results_link\", \"/analysis/results\")\nend\n\n# Access via soft links\njldopen(\"example.jld2\", \"r\") do f\n    original = f[\"dataset1\"]    # [1, 2, 3, 4, 5]\n    via_link = f[\"data_alias\"]  # [1, 2, 3, 4, 5] (same data)\nend","category":"page"},{"location":"external_links/#API-Reference","page":"Dataset Links","title":"API Reference","text":"","category":"section"},{"location":"external_links/#External-Links","page":"Dataset Links","title":"External Links","text":"","category":"section"},{"location":"external_links/#create_external_link!(file_or_group,-name,-external_file,-object_path)","page":"Dataset Links","title":"create_external_link!(file_or_group, name, external_file, object_path)","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Create an external link pointing to an object in another file.","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Parameters:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"file_or_group: JLDFile or Group to create the link in\nname: Name for the new link\nexternal_file: Path to the external HDF5/JLD2 file\nobject_path: Path to the object within the external file (should start with \"/\")","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Example:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"jldopen(\"main.jld2\", \"w\") do f\n    create_external_link!(f, \"remote_data\", \"../shared/data.jld2\", \"/measurements/temperature\")\nend","category":"page"},{"location":"external_links/#Soft-Links","page":"Dataset Links","title":"Soft Links","text":"","category":"section"},{"location":"external_links/#create_soft_link!(file_or_group,-name,-target_path)","page":"Dataset Links","title":"create_soft_link!(file_or_group, name, target_path)","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Create a soft link pointing to a path within the same file.","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Parameters:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"file_or_group: JLDFile or Group to create the link in\nname: Name for the new link\ntarget_path: Path to the target object (absolute path starting with \"/\")","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Example:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"jldopen(\"data.jld2\", \"w\") do f\n    f[\"original_data\"] = [1, 2, 3]\n    create_soft_link!(f, \"data_shortcut\", \"/original_data\")\nend","category":"page"},{"location":"external_links/#Advanced-Usage","page":"Dataset Links","title":"Advanced Usage","text":"","category":"section"},{"location":"external_links/#Working-with-Groups","page":"Dataset Links","title":"Working with Groups","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"jldopen(\"structured.jld2\", \"w\") do f\n    # Create nested structure\n    exp_group = JLD2.Group(f, \"experiment\")\n    data_group = JLD2.Group(exp_group, \"data\")\n    results_group = JLD2.Group(exp_group, \"results\")\n\n    data_group[\"raw\"] = collect(1:100)\n    results_group[\"processed\"] = collect(1:100) .^ 2\n\n    # Create soft links for easier access\n    create_soft_link!(f, \"raw_data\", \"/experiment/data/raw\")\n    create_soft_link!(f, \"final_results\", \"/experiment/results/processed\")\n\n    # External link to shared calibration data\n    create_external_link!(f, \"calibration\", \"calibration.jld2\", \"/standard_curve\")\nend","category":"page"},{"location":"external_links/#Cross-File-Data-Workflows","page":"Dataset Links","title":"Cross-File Data Workflows","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"# Step 1: Create base data\njldsave(\"measurements.jld2\";\n        voltage=[1.2, 1.5, 1.8, 2.1],\n        current=[0.1, 0.2, 0.3, 0.4])\n\n# Step 2: Create analysis file with external links\njldopen(\"analysis.jld2\", \"w\") do f\n    # Link to external measurements\n    create_external_link!(f, \"voltage_data\", \"measurements.jld2\", \"/voltage\")\n    create_external_link!(f, \"current_data\", \"measurements.jld2\", \"/current\")\n\n    # Process the external data and save results locally\n    voltage = f[\"voltage_data\"]  # Transparently loads from external file\n    current = f[\"current_data\"]\n\n    f[\"resistance\"] = voltage ./ current\n    f[\"power\"] = voltage .* current\n\n    # Create soft links to results\n    create_soft_link!(f, \"R\", \"/resistance\")\n    create_soft_link!(f, \"P\", \"/power\")\nend\n\n# Step 3: Access everything through high-level API\nresults = load(\"analysis.jld2\")\n# results contains: voltage_data, current_data, resistance, power, R, P","category":"page"},{"location":"external_links/#Error-Handling","page":"Dataset Links","title":"Error Handling","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"jldopen(\"main.jld2\", \"w\") do f\n    try\n        # This will fail if the external file doesn't exist\n        create_external_link!(f, \"missing\", \"nonexistent.jld2\", \"/data\")\n    catch e\n        println(\"External link creation failed: $e\")\n    end\n\n    try\n        # This will fail if accessed and the path doesn't exist\n        create_soft_link!(f, \"broken\", \"/nonexistent/path\")\n        f[\"broken\"]  # Error occurs here during access\n    catch e\n        println(\"Soft link resolution failed: $e\")\n    end\nend","category":"page"},{"location":"external_links/#Performance-Characteristics","page":"Dataset Links","title":"Performance Characteristics","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Hard Links: ~0.03ms per access (baseline)\nSoft Links: ~0.001ms per access (cached resolution)\nExternal Links: ~0.2ms per access (with file handle caching)\nExternal File Caching: 200-300x speedup for repeated access to same external file","category":"page"},{"location":"external_links/#HDF5-Tool-Compatibility","page":"Dataset Links","title":"HDF5 Tool Compatibility","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Files with external and soft links are fully compatible with standard HDF5 tools:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"# View file structure showing links\nh5dump -H main.jld2\n\n# Access data through external links\nh5dump -d /external_temp main.jld2\n\n# Validate file structure\nh5debug main.jld2","category":"page"},{"location":"external_links/#Security-Considerations","page":"Dataset Links","title":"Security Considerations","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Path Validation: External file paths are validated to prevent directory traversal attacks\nRelative Paths: External links support relative paths resolved from the current file's directory\nAccess Control: Optional access policies can be configured for production environments","category":"page"},{"location":"external_links/#Best-Practices","page":"Dataset Links","title":"Best Practices","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Use Relative Paths: When possible, use relative paths for external links to make file sets portable\nError Handling: Always handle potential errors when accessing external links\nFile Organization: Use external links to create modular data workflows\nPerformance: External links are cached automatically - no manual optimization needed\nHDF5 Compatibility: Files with links can be read by any HDF5-compatible tool","category":"page"},{"location":"external_links/#Migration-from-Hard-Links","page":"Dataset Links","title":"Migration from Hard Links","text":"","category":"section"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"Existing JLD2 code continues to work unchanged. To add link features:","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"# Before (hard links only)\njldopen(\"data.jld2\", \"w\") do f\n    f[\"dataset\"] = data\nend\n\n# After (with links for better organization)\njldopen(\"data.jld2\", \"w\") do f\n    f[\"raw_dataset\"] = data\n    create_soft_link!(f, \"dataset\", \"/raw_dataset\")  # Alias for compatibility\n    create_external_link!(f, \"reference\", \"standards.jld2\", \"/reference_data\")\nend","category":"page"},{"location":"external_links/","page":"Dataset Links","title":"Dataset Links","text":"External links and soft links provide powerful tools for organizing complex data workflows while maintaining full backward compatibility with existing JLD2 code.","category":"page"},{"location":"compression/#Compression","page":"Compression","title":"Compression","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"JLD2 supports compression of isbits arrays. This includes the typical Array{Float64} but also arrays of custom structs that are immutable and only consist of basic number type fields.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"To enable the default compression, you can write:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2\nsave(\"example.jld2\", \"large_array\", zeros(10000); compress = true)","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Alternatively use","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"jldsave(\"example.jld2\", true; large_array=zeros(10000))","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"or","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"jldopen(\"example.jld2\", \"w\"; compress = true) do f\n    f[\"large_array\"] = zeros(10000)\nend","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"When reading a file JLD2 detects compression and automatically decompresses the data so it is not necessary to pass any extra parameters for that case. However, JLD2 will prompt you to install and load the necessary filter packages if they are not yet available.","category":"page"},{"location":"compression/#Compression-Filter-API","page":"Compression","title":"Compression Filter API","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"JLD2 can use a number of different compression algorithms, also called filters. These can be used individually and even chained which can be useful for some types of data. The filter used by compress = true is the Deflate() compression filter.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"note: Note\nThe default Deflate() compression is always available but some others will need to be installed separately. JLD2 will throw an error if the required filter package is not loaded, prompting you to install and load the appropriate package e.g. : using JLD2, JLD2Lz4.","category":"page"},{"location":"compression/#Installing-Filter-Packages","page":"Compression","title":"Installing Filter Packages","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"To use compression filters, you need to install and load the corresponding packages:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using Pkg\n# For other compression algorithms\nPkg.add(\"JLD2Lz4\")\nusing JLD2, JLD2Lz4  # Load the package you need","category":"page"},{"location":"compression/#Available-Compression-Filters","page":"Compression","title":"Available Compression Filters","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"This compression system is analogous to that of HDF5 and uses the same underlying compression libraries. JLD2 files with compressed datasets can in many cases be opened using HDF5 and similarly, JLD2 will be able to read most HDF5 files even with compression. The compression filters available for JLD2 are:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Filter Package Filter Type Notes\nbuilt in Shuffle Rearrangement of bytes useful as a preprocess filter\nbuilt in Deflate Default compression, very widely used, good compatibility\nbuilt in ZstdFilter Fast, wide range of compression size vs speed trade-offs\nJLD2Bzip2 Bzip2Filter Good compression ratio, can be slower\nJLD2Lz4 Lz4Filter Very fast compression/decompression","category":"page"},{"location":"compression/#Using-Specific-Filters","page":"Compression","title":"Using Specific Filters","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"To use a specific compression filter, pass an instance of the filter instead of true:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2, JLD2Lz4\n\n# Using Lz4 compression\njldopen(\"example.jld2\", \"w\"; compress = Lz4Filter()) do f\n    f[\"large_array\"] = zeros(10000)\nend\n\n# Zstd with non-standard compression level\njldopen(\"example.jld2\", \"w\"; compress = ZstdFilter(9)) do f\n    f[\"large_array\"] = zeros(10000)\nend","category":"page"},{"location":"compression/#Using-Multiple-Filters","page":"Compression","title":"Using Multiple Filters","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"JLD2 supports combining multiple filters for advanced compression strategies. This is particularly useful when combining preprocessing filters (like shuffling) with compression filters. Simply provide a vector of filters:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2\n\n# Combine Shuffle preprocessing with Deflate compression\nfilters = [Shuffle(), Deflate()]\n\njldopen(\"example.jld2\", \"w\"; compress = filters) do f\n    # Benefits from byte shuffling\n    # Only the lowest byte of each element is non-zero\n    # Shuffle() reorders the bytes of all elements from e.g.\n    # [123123123] to [111222333]\n    # where each digit refers to the nth byte of an array element.\n    f[\"numeric_data\"] = UInt.(rand(UInt8, 10000))\nend","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"note: Note\nFilters in a pipeline are applied in order during compression and in reverse order during decompression. Preprocessing filters (like Shuffle) should typically come before compression filters.","category":"page"},{"location":"compression/#Filter-Configuration-Examples","page":"Compression","title":"Filter Configuration Examples","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"Different filters support various configuration options:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2, JLD2Lz4, JLD2Bzip2\n\n# Zstd with different compression levels\nzstd_fast = ZstdFilter(level=1)    # Fast compression\nzstd_best = ZstdFilter(level=22)   # Best compression\n\n# Bzip2 with custom block size\nbzip2_filter = Bzip2Filter(blocksize100k=4)\n\n# Example usage\njldopen(\"example.jld2\", \"w\") do f\n    write(f, \"fast_data\", zeros(UInt8, 10000); compress=zstd_fast)\n    write(f, \"small_data\", randn(10000); compress=zstd_best)\n    write(f, \"archive_data\", randn(1000); compress=bzip2_filter)\nend","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Depending on the characteristics of your datasets, some configurations may be more efficient than others.","category":"page"},{"location":"compression/#Manually-selecting-compression-for-datasets","page":"Compression","title":"Manually selecting compression for datasets","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"Sometimes you may know that some of your arrays are easily compressible and that for others it is not worth the effort. For precise control, the write function takes an optional keyword argument to override the file compression settings.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"using JLD2\n\njldopen(\"example.jld2\", \"w\"; compress=ZstdFilter()) do f\n    # This gets compressed with the ZstdFilter\n    write(f, \"default_array\", zeros(10000))\n\n    # Don't compress this\n    write(f, \"random_array\", rand(10000); compress=false)\n\n    # Override the above compression filter and use a different one\n    write(f, \"zlib_array\", zeros(10000); compress=Deflate())\n\n    # Alternatively, use the same filter but with different configuration\n    write(f, \"fast_compressed\", rand(10000); compress=ZstdFilter(level= -20))\nend","category":"page"},{"location":"compression/#Compatibility-and-Migration-from-v0.5-to-v0.6","page":"Compression","title":"Compatibility and Migration from v0.5 to v0.6","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"File Compatibility: Files created with the old API can be read with the new system. Files created with the v0.6 filter API may not be able to read by older versions of JLD2, see the compatibility table below for more information.\nPerformance: Compression performance and file sizes remain the same as the underlying compression libraries are unchanged.\nHDF5 Compatibility: The new API is analogous to HDF5.jl, making it easier to work with HDF5 files and improving interoperability.","category":"page"},{"location":"compression/#Filter-Compatibility-Table","page":"Compression","title":"Filter Compatibility Table","text":"","category":"section"},{"location":"compression/","page":"Compression","title":"Compression","text":"The following table shows which JLD2 versions can decode data compressed using different filter features:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Filter feature JLD2 versions able to decode\nDeflate Since 0.2.0\nBzip2Filter Since 0.4.4\nZstdFilter Since 0.4.49\nShuffle Since 0.6.0\nLz4Filter Since 0.6.0\nmultiple filters Since 0.6.0","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Notes:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"Data compressed with LZ4FrameCompressor in previous versions","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"can be read if JLD2Lz4 is loaded. Data compressed with Lz4Filter cannot be read by JLD2 versions before 0.6.0.","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"For code migration, the main change is in how you specify compression filters:","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"# Old API\n# using JLD2, CodecZlib\n# jldopen(\"file.jld2\", \"w\"; compress = ZlibCompressor()) do f\n\n# New API\nusing JLD2\njldopen(\"file.jld2\", \"w\"; compress = Deflate()) do f\n    # ...\nend","category":"page"},{"location":"compression/","page":"Compression","title":"Compression","text":"The simplest usage option of compress=true still works as before.","category":"page"},{"location":"compression/#API-Docstrings","page":"Compression","title":"API Docstrings","text":"","category":"section"},{"location":"compression/#JLD2.Filters","page":"Compression","title":"JLD2.Filters","text":"JLD2.Filters\n\nThis module contains the interface for using filters in JLD2.jl.\n\n\n\n\n\n","category":"module"},{"location":"compression/#JLD2.Filters.Deflate","page":"Compression","title":"JLD2.Filters.Deflate","text":"Deflate <: Filter\n\nThe Deflate filter can be used to compress datasets. It uses the well-known and widely used zlib (deflate) compression algorithm. This is filter id 1.\n\nKeyword arguments:\n\nlevel::Integer = 5: Compression level, between 0 and 9. Default is 5.\nLarger numbers lead to better compression, but also to longer runtime.\n\n\n\n\n\n","category":"type"},{"location":"compression/#JLD2.Filters.Shuffle","page":"Compression","title":"JLD2.Filters.Shuffle","text":"Shuffle() <: Filter\n\nThe Shuffle filter can be used as part of a filter pipeline to compress datasets. It rearranges the bytes of elements in an array to improve compression efficiency. It is not a compression filter by itself, but can be used in conjunction with other compression filters like Deflate or ZstdFilter.\n\nIt can be useful when the array, for example, contains unsigned integer UInt64 and all values are small. Then all the upper bytes of the eight byte integer are zero. This filter will rearrange the bytes so that all the least significant bytes are at the beginning of the array, followed by the second least significant bytes, and so on, which simplifies the compression of the data.\n\n\n\n\n\n","category":"type"},{"location":"compression/#JLD2.Filters.ZstdFilter","page":"Compression","title":"JLD2.Filters.ZstdFilter","text":"ZstdFilter <: Filter\n\nThe ZstdFilter can be used to compress datasets using the Zstandard compression algorithm. This is filter id 32015.\n\nKeyword arguments:\n\nlevel::Integer = 3: Compression level, regular levels are 1-22.\nLevels ≥ 20 should be used with caution, as they require more memory. The zstd library also offers negative compression levels, which extend the range of speed vs. ratio preferences. The lower the level, the faster the speed (at the cost of compression). 0 is a special value for the default level. The level will be clamped to the range allowed by the zstd library.\n\n\n\n\n\n","category":"type"}]
}
