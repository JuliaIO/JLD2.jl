================================================================================
ANALYSIS: Simple structure with two fields
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestSimple}, hflags, hsize, kw)
        default_version = 1
        version = Main.get(kw, :version, default_version)
        Main.jlwrite(fly, UInt8(version))
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        Main.jlwrite(fly, UInt8(flags))
    end
    function compute_size(::Main.Val{Main.TestSimple}, hflags, hsize, kw)
        offset = 0
        default_version = 1
        version = Main.get(kw, :version, default_version)
        offset += Main.sizeof(UInt8)
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        offset += Main.sizeof(UInt8)
        return offset
    end
    function messageshow(::Main.Val{Main.TestSimple}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :version => version)
        flags = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :flags => flags)
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestSimple, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :version
            offset = getfield(m, :address)
            seek(io, offset)
            value_version = jlread(io, UInt8)::UInt8
            return value_version
        end
        if s == :flags
            offset = getfield(m, :address)
            offset += sizeof(UInt8)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            return value_flags
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end

================================================================================
ANALYSIS: Conditional fields (shows redundant flag reads in getproperty)
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestConditional}, hflags, hsize, kw)
        default_version = 1
        version = Main.get(kw, :version, default_version)
        Main.jlwrite(fly, UInt8(version))
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        Main.jlwrite(fly, UInt8(flags))
        isset(flags, 0) && begin
                Main.haskey(kw, :max_value) || Main.throw(Main.ArgumentError("Argument :max_value is required"))
                max_value = kw.max_value
                Main.jlwrite(fly, Int64(max_value))
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :min_value) || Main.throw(Main.ArgumentError("Argument :min_value is required"))
                min_value = kw.min_value
                Main.jlwrite(fly, Int64(min_value))
            end
    end
    function compute_size(::Main.Val{Main.TestConditional}, hflags, hsize, kw)
        offset = 0
        default_version = 1
        version = Main.get(kw, :version, default_version)
        offset += Main.sizeof(UInt8)
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        offset += Main.sizeof(UInt8)
        isset(flags, 0) && begin
                Main.haskey(kw, :max_value) || Main.throw(Main.ArgumentError("Argument :max_value is required"))
                max_value = kw.max_value
                offset += Main.sizeof(Int64)
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :min_value) || Main.throw(Main.ArgumentError("Argument :min_value is required"))
                min_value = kw.min_value
                offset += Main.sizeof(Int64)
            end
        return offset
    end
    function messageshow(::Main.Val{Main.TestConditional}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        version = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :version => version)
        flags = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :flags => flags)
        isset(flags, 0) && begin
                max_value = Main.jlread(io, Int64)
                Main.push!(keyvalue, :max_value => max_value)
            end
        isset(flags, 1) && begin
                min_value = Main.jlread(io, Int64)
                Main.push!(keyvalue, :min_value => min_value)
            end
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestConditional, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :version
            offset = getfield(m, :address)
            seek(io, offset)
            value_version = jlread(io, UInt8)::UInt8
            return value_version
        end
        if s == :flags
            offset = getfield(m, :address)
            offset += sizeof(UInt8)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            return value_flags
        end
        if s == :max_value
            offset = getfield(m, :address)
            offset += sizeof(UInt8)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            offset += sizeof(UInt8)
            seek(io, offset)
            if isset(value_flags, 0)
                value_max_value = jlread(io, Int64)::Int64
                return value_max_value
            end
        end
        if s == :min_value
            offset = getfield(m, :address)
            offset += sizeof(UInt8)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            offset += sizeof(UInt8)
            isset(value_flags, 0) && (offset += sizeof(Int64))
            seek(io, offset)
            if isset(value_flags, 1)
                value_min_value = jlread(io, Int64)::Int64
                return value_min_value
            end
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end

================================================================================
ANALYSIS: Multiple fields depending on same flag bit
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestMultiDep}, hflags, hsize, kw)
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        Main.jlwrite(fly, UInt8(flags))
        isset(flags, 0) && begin
                Main.haskey(kw, :field_a) || Main.throw(Main.ArgumentError("Argument :field_a is required"))
                field_a = kw.field_a
                Main.jlwrite(fly, Int64(field_a))
            end
        isset(flags, 0) && begin
                Main.haskey(kw, :field_b) || Main.throw(Main.ArgumentError("Argument :field_b is required"))
                field_b = kw.field_b
                Main.jlwrite(fly, Int32(field_b))
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :field_c) || Main.throw(Main.ArgumentError("Argument :field_c is required"))
                field_c = kw.field_c
                Main.jlwrite(fly, Int64(field_c))
            end
    end
    function compute_size(::Main.Val{Main.TestMultiDep}, hflags, hsize, kw)
        offset = 0
        default_flags = 0
        flags = Main.get(kw, :flags, default_flags)
        offset += Main.sizeof(UInt8)
        isset(flags, 0) && begin
                Main.haskey(kw, :field_a) || Main.throw(Main.ArgumentError("Argument :field_a is required"))
                field_a = kw.field_a
                offset += Main.sizeof(Int64)
            end
        isset(flags, 0) && begin
                Main.haskey(kw, :field_b) || Main.throw(Main.ArgumentError("Argument :field_b is required"))
                field_b = kw.field_b
                offset += Main.sizeof(Int32)
            end
        isset(flags, 1) && begin
                Main.haskey(kw, :field_c) || Main.throw(Main.ArgumentError("Argument :field_c is required"))
                field_c = kw.field_c
                offset += Main.sizeof(Int64)
            end
        return offset
    end
    function messageshow(::Main.Val{Main.TestMultiDep}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        flags = Main.jlread(io, UInt8)
        Main.push!(keyvalue, :flags => flags)
        isset(flags, 0) && begin
                field_a = Main.jlread(io, Int64)
                Main.push!(keyvalue, :field_a => field_a)
            end
        isset(flags, 0) && begin
                field_b = Main.jlread(io, Int32)
                Main.push!(keyvalue, :field_b => field_b)
            end
        isset(flags, 1) && begin
                field_c = Main.jlread(io, Int64)
                Main.push!(keyvalue, :field_c => field_c)
            end
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestMultiDep, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :flags
            offset = getfield(m, :address)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            return value_flags
        end
        if s == :field_a
            offset = getfield(m, :address)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            offset += sizeof(UInt8)
            seek(io, offset)
            if isset(value_flags, 0)
                value_field_a = jlread(io, Int64)::Int64
                return value_field_a
            end
        end
        if s == :field_b
            offset = getfield(m, :address)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            offset += sizeof(UInt8)
            isset(value_flags, 0) && (offset += sizeof(Int64))
            seek(io, offset)
            if isset(value_flags, 0)
                value_field_b = jlread(io, Int32)::Int32
                return value_field_b
            end
        end
        if s == :field_c
            offset = getfield(m, :address)
            seek(io, offset)
            value_flags = jlread(io, UInt8)::UInt8
            offset += sizeof(UInt8)
            isset(value_flags, 0) && (offset += sizeof(Int64))
            isset(value_flags, 0) && (offset += sizeof(Int32))
            seek(io, offset)
            if isset(value_flags, 1)
                value_field_c = jlread(io, Int64)::Int64
                return value_field_c
            end
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end

================================================================================
ANALYSIS: Sequential variable-length reads
================================================================================
begin
    function jlwrite(fly, ::Main.Val{Main.TestSequential}, hflags, hsize, kw)
        Main.haskey(kw, :name_len) || Main.throw(Main.ArgumentError("Argument :name_len is required"))
        name_len = kw.name_len
        Main.jlwrite(fly, UInt16(name_len))
        Main.haskey(kw, :name) || Main.throw(Main.ArgumentError("Argument :name is required"))
        name = kw.name
        Main.jlwrite(fly, name)
        Main.haskey(kw, :data_size) || Main.throw(Main.ArgumentError("Argument :data_size is required"))
        data_size = kw.data_size
        Main.jlwrite(fly, UInt32(data_size))
        Main.haskey(kw, :data) || Main.throw(Main.ArgumentError("Argument :data is required"))
        data = kw.data
        Main.jlwrite(fly, data)
    end
    function compute_size(::Main.Val{Main.TestSequential}, hflags, hsize, kw)
        offset = 0
        Main.haskey(kw, :name_len) || Main.throw(Main.ArgumentError("Argument :name_len is required"))
        name_len = kw.name_len
        offset += Main.sizeof(UInt16)
        Main.haskey(kw, :name) || Main.throw(Main.ArgumentError("Argument :name is required"))
        name = kw.name
        offset += name_len
        Main.haskey(kw, :data_size) || Main.throw(Main.ArgumentError("Argument :data_size is required"))
        data_size = kw.data_size
        offset += Main.sizeof(UInt32)
        Main.haskey(kw, :data) || Main.throw(Main.ArgumentError("Argument :data is required"))
        data = kw.data
        offset += data_size
        return offset
    end
    function messageshow(::Main.Val{Main.TestSequential}, m::Main.Message, hflags = 0x00, hsize = 0x0000)
        io = m.io
        Main.seek(io, m.address)
        offset = 0
        keyvalue = Main.Pair{Main.Symbol, Main.Any}[]
        name_len = Main.jlread(io, UInt16)
        Main.push!(keyvalue, :name_len => name_len)
        name = Main.String(Main.jlread(io, Main.UInt8, name_len))
        Main.push!(keyvalue, :name => name)
        data_size = Main.jlread(io, UInt32)
        Main.push!(keyvalue, :data_size => data_size)
        data = Main.jlread(io, Main.UInt8, data_size)
        Main.push!(keyvalue, :data => data)
        return keyvalue
    end
    function Base.getproperty(tw::Main.HmWrap{Main.TestSequential, iot}, s::Main.Symbol) where iot
        s == :size && return Main.getfield(tw, s)
        s == :hflags && return Main.getfield(tw, s)
        s == :m && return Main.getfield(tw, s)
        m = Main.getfield(tw, :m)::Main.Message{iot}
        hflags = Main.getfield(tw, :hflags)
        hsize = Main.getfield(tw, :size)
        io = Main.getfield(m, :io)::iot
        if s == :name_len
            offset = getfield(m, :address)
            seek(io, offset)
            value_name_len = jlread(io, UInt16)::UInt16
            return value_name_len
        end
        if s == :name
            offset = getfield(m, :address)
            seek(io, offset)
            value_name_len = jlread(io, UInt16)::UInt16
            offset += sizeof(UInt16)
            seek(io, offset)
            value_name = String(jlread(io, UInt8, value_name_len))
            return value_name
        end
        if s == :data_size
            offset = getfield(m, :address)
            seek(io, offset)
            value_name_len = jlread(io, UInt16)::UInt16
            offset += sizeof(UInt16)
            offset += value_name_len
            seek(io, offset)
            value_data_size = jlread(io, UInt32)::UInt32
            return value_data_size
        end
        if s == :data
            offset = getfield(m, :address)
            seek(io, offset)
            value_name_len = jlread(io, UInt16)::UInt16
            offset += sizeof(UInt16)
            offset += value_name_len
            seek(io, offset)
            value_data_size = jlread(io, UInt32)::UInt32
            offset += sizeof(UInt32)
            seek(io, offset)
            value_data = jlread(io, UInt8, value_data_size)::Vector{UInt8}
            return value_data
        end
        Main.throw(Main.ArgumentError(Main.string("property ", s, " not found")))
    end
    Main.nothing
end
