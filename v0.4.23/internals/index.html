<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals &amp; Design · Julia Data Format</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Julia Data Format</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Basics</a></li><li><a class="tocitem" href="../customserialization/">Custom Serialization</a></li><li><a class="tocitem" href="../compression/">Compression</a></li><li class="is-active"><a class="tocitem" href>Internals &amp; Design</a><ul class="internal"><li><a class="tocitem" href="#File-Interface"><span>File Interface</span></a></li></ul></li><li><a class="tocitem" href="../hdf5compat/">HDF5 Compatibility</a></li><li><a class="tocitem" href="../advanced/">Advanced Usage</a></li><li><a class="tocitem" href="../legacy/">Legacy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals &amp; Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals &amp; Design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIO/JLD2.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals-and-Design"><a class="docs-heading-anchor" href="#Internals-and-Design">Internals &amp; Design</a><a id="Internals-and-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-and-Design" title="Permalink"></a></h1><h2 id="File-Interface"><a class="docs-heading-anchor" href="#File-Interface">File Interface</a><a id="File-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#File-Interface" title="Permalink"></a></h2><p>The JLDFile object mimics the API of <code>Base.Dict</code> as much as it can. In particular, <code>keys</code>, <code>length</code>, <code>haskey</code>, <code>isempty</code>, <code>get</code>, <code>get!</code> should work as expected.</p><article class="docstring"><header><a class="docstring-binding" id="JLD2.CustomSerialization" href="#JLD2.CustomSerialization"><code>JLD2.CustomSerialization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CustomSerialization{T,S}</code></pre><p>On-disk representation for data that is written as if it were of Julia type <code>T</code>, but is read as type <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.GlobalHeap" href="#JLD2.GlobalHeap"><code>JLD2.GlobalHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalHeap</code></pre><p>Represents an HDF5 global heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.Group" href="#JLD2.Group"><code>JLD2.Group</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Group(file)</code></pre><p>JLD2 group object. </p><p><strong>Advanced Usage</strong></p><p>Takes two optional keyword arguments:     est<em>num</em>entries::Int=4     est<em>link</em>name_len::Int=8 These determine how much (additional) empty space should be allocated for the group description. (list of entries) This can be useful for performance when one expects to append many additional datasets after first writing the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.Group-Tuple{JLD2.JLDFile, AbstractString}" href="#JLD2.Group-Tuple{JLD2.JLDFile, AbstractString}"><code>JLD2.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Group(f::JLDFile, name::AbstractString)</code></pre><p>Construct an empty group named <code>name</code> at the top level of <code>JLDFile</code> <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.Group-Union{Tuple{T}, Tuple{JLD2.Group{T}, AbstractString}} where T" href="#JLD2.Group-Union{Tuple{T}, Tuple{JLD2.Group{T}, AbstractString}} where T"><code>JLD2.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Group(g::Group, name::AbstractString)</code></pre><p>Construct a group named <code>name</code> as a child of group <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.H5Datatype" href="#JLD2.H5Datatype"><code>JLD2.H5Datatype</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">H5Datatype</code></pre><p>Supertype of all HDF5 datatypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.IndirectPointer" href="#JLD2.IndirectPointer"><code>JLD2.IndirectPointer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndirectPointer</code></pre><p>When writing data, we may need to enlarge the memory mapping, which would invalidate any memory addresses arising from the old <code>mmap</code> pointer. <code>IndirectPointer</code> holds a pointer to the <code>startptr</code> field of an MmapIO, and the offset relative to that pointer. It defers computing a memory address until converted to a Ptr{T}, so the memory mapping can be enlarged and addresses will remain valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.InlineUnionEl" href="#JLD2.InlineUnionEl"><code>JLD2.InlineUnionEl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InlineUnionEl{T1,T2}(mask::UInt8, t1::T1, t2::T2)</code></pre><p>Custom serialization struct for two member isbits union fields e.g. in other structs or arrays. To indicate that t1 is relevant the mask takes the value <code>UInt8(0)</code> and for t2 <code>UInt8(255)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.JLDFile" href="#JLD2.JLDFile"><code>JLD2.JLDFile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLDFile{T&lt;:IO}</code></pre><p>JLD file object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.JLDWriteSession" href="#JLD2.JLDWriteSession"><code>JLD2.JLDWriteSession</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLDWriteSession{T}</code></pre><p>A JLDWriteSession keeps track of references to serialized objects. If <code>T</code> is a Dict, <code>h5offset</code> maps an object ID (returned by calling <code>objectid</code>) to th <code>RelOffset</code> of the written dataset. If it is <code>Union{}</code>, then references are not tracked, and objects referenced multiple times are written multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.ReadRepresentation" href="#JLD2.ReadRepresentation"><code>JLD2.ReadRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReadRepresentation{T,ODR}</code></pre><p>A type encoding both the Julia type <code>T</code> and the on-disk (HDF5) representation <code>ODR</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.RelOffset" href="#JLD2.RelOffset"><code>JLD2.RelOffset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RelOffset</code></pre><p>Represents an HDF5 relative offset. This differs from a file offset (used elsewhere) in that it is relative to the superblock base address. In practice, this means that <code>FILE_HEADER_LENGTH</code>has been subtracted. <code>fileoffset</code> and <code>h5offset</code> convert between <code>RelOffsets</code> and file offsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.TypeMappingException" href="#JLD2.TypeMappingException"><code>JLD2.TypeMappingException</code></a> — <span class="docstring-category">Type</span></header><section><div><p>constructrr(f::JLDFile, T::DataType, dt::CompoundType, attrs::Vector{ReadAttribute},             hard_failure::Bool=false)</p><p>Constructs a ReadRepresentation for a given type. This is the generic method for all types not specially handled below.</p><p>If hard_failure is true, then throw a TypeMappingException instead of attempting reconstruction. This helps in cases where we can&#39;t know if reconstructed parametric types will have a matching memory layout without first inspecting the memory layout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.behead-Tuple{UnionAll}" href="#JLD2.behead-Tuple{UnionAll}"><code>JLD2.behead</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">behead(T)</code></pre><p>Given a UnionAll type, recursively eliminates the <code>where</code> clauses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.construct_array-Union{Tuple{T}, Tuple{IO, Type{T}, Val{1}}} where T" href="#JLD2.construct_array-Union{Tuple{T}, Tuple{IO, Type{T}, Val{1}}} where T"><code>JLD2.construct_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_array{T}(io::IO, ::Type{T}, ::Val{ndims})</code></pre><p>Construct array by reading <code>ndims</code> dimensions from <code>io</code>. Assumes <code>io</code> has already been seeked to the correct position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.fileoffset-Tuple{JLD2.JLDFile, JLD2.RelOffset}" href="#JLD2.fileoffset-Tuple{JLD2.JLDFile, JLD2.RelOffset}"><code>JLD2.fileoffset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fileoffset(f::JLDFile, x::RelOffset)</code></pre><p>Converts an offset <code>x</code> relative to the superblock of file <code>f</code> to an absolute offset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.group_payload_size-Tuple{Any}" href="#JLD2.group_payload_size-Tuple{Any}"><code>JLD2.group_payload_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">group_payload_size(g)</code></pre><p>Returns the size of a group payload, including link info, group info, and link messages, but not the object header. Provides space after the last object message for a continuation message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.h5offset-Tuple{JLD2.JLDFile, Int64}" href="#JLD2.h5offset-Tuple{JLD2.JLDFile, Int64}"><code>JLD2.h5offset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">h5offset(f::JLDFile, x::RelOffset)</code></pre><p>Converts an absolute file offset <code>x</code> to an offset relative to the superblock of file <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}" href="#JLD2.jld_finalizer-Tuple{JLD2.JLDFile{JLD2.MmapIO}}"><code>JLD2.jld_finalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jld_finalizer(f::JLDFile)</code></pre><p>When a JLDFile is finalized, it is possible that the <code>MmapIO</code> has been munmapped, since Julia does not guarantee finalizer order. This means that the underlying file may be closed before we get a chance to write to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.jldopen" href="#JLD2.jldopen"><code>JLD2.jldopen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jldopen(fname::AbstractString, mode::AbstractString; iotype=MmapIO, compress=false, typemap=Dict())</code></pre><p>Opens a JLD2 file at path <code>fname</code>.</p><p><code>&quot;r&quot;</code>: Open for reading only, failing if no file exists <code>&quot;r+&quot;</code>: Open for reading and writing, failing if no file exists <code>&quot;w&quot;</code>/<code>&quot;w+&quot;</code>: Open for reading and writing, overwriting the file if it already exists <code>&quot;a&quot;</code>/<code>&quot;a+&quot;</code>: Open for reading and writing, creating a new file if none exists, but               preserving the existing file if one is present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.jldsave-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString, Any}, Tuple{AbstractString, Any, T}} where T&lt;:Union{Type{IOStream}, Type{JLD2.MmapIO}}" href="#JLD2.jldsave-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString, Any}, Tuple{AbstractString, Any, T}} where T&lt;:Union{Type{IOStream}, Type{JLD2.MmapIO}}"><code>JLD2.jldsave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jldsave(filename, compress=false; kwargs...)</code></pre><p>Creates a JLD2 file at <code>filename</code> and stores the variables given as keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-none">jldsave(&quot;example.jld2&quot;; a=1, b=2, c)</code></pre><p>is equivalent to</p><pre><code class="language-none">jldopen(&quot;example.jld2, &quot;w&quot;) do f
    f[&quot;a&quot;] = 1
    f[&quot;b&quot;] = 2
    f[&quot;c&quot;] = c
end</code></pre><p>To choose the io type <code>IOStream</code> instead of the default <code>MmapIO</code> use  <code>jldsave(fn, IOStream; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.link_size-Tuple{String}" href="#JLD2.link_size-Tuple{String}"><code>JLD2.link_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">link_size(name::String)</code></pre><p>Returns the size of a link message, including message header.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.links_size-Tuple{Any}" href="#JLD2.links_size-Tuple{Any}"><code>JLD2.links_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">links_size(pairs)</code></pre><p>Returns the size of several link messages. <code>pairs</code> is an iterator of <code>String =&gt; RelOffset</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.load_datatypes-Tuple{JLD2.JLDFile}" href="#JLD2.load_datatypes-Tuple{JLD2.JLDFile}"><code>JLD2.load_datatypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_datatypes(f::JLDFile)</code></pre><p>Populate f.datatypes and f.jlh5types with all of the committed datatypes from a file. We need to do this before writing to make sure we reuse written datatypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.load_object-Tuple{Any}" href="#JLD2.load_object-Tuple{Any}"><code>JLD2.load_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_object(filename)</code></pre><p>Returns the only available object from the JLD2 file <code>filename</code> (The stored object name is inconsequential). If the file contains more than one or no objects, the function throws an <code>ArgumentError</code>.</p><p>For loading more than one object, use <a href="legacy/#JLD2.@load"><code>@load</code></a> macro, <a href="internals/#JLD2.jldopen"><code>jldopen</code></a> or the FileIO API.</p><p><strong>Example</strong></p><p>To load the only object from the JLD2 file example.jld2:</p><pre><code class="language-none">hello = &quot;world&quot;
save_object(&quot;example.jld2&quot;, hello)
hello_loaded = load_object(&quot;example.jld2&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.lookup_offset-Tuple{JLD2.Group, AbstractString}" href="#JLD2.lookup_offset-Tuple{JLD2.Group, AbstractString}"><code>JLD2.lookup_offset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lookup_offset(g::Group, name::AbstractString) -&gt; RelOffset</code></pre><p>Lookup the offset of a dataset in a group. Returns <code>UNDEFINED_ADDRESS</code> if the dataset is not present. Does not inspect <code>unwritten_child_groups</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.pathize-Tuple{JLD2.Group, AbstractString, Bool}" href="#JLD2.pathize-Tuple{JLD2.Group, AbstractString, Bool}"><code>JLD2.pathize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pathize(g::Group, name::AbstractString, create::Bool) -&gt; Tuple{Group,String}</code></pre><p>Converts a path to a group and name object. If <code>create</code> is true, any intermediate groups will be created, and the dataset name will be checked for uniqueness with existing names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.prewrite-Tuple{JLD2.JLDFile}" href="#JLD2.prewrite-Tuple{JLD2.JLDFile}"><code>JLD2.prewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prewrite(f::JLDFile)</code></pre><p>Check that a JLD file is actually writable, and throw an error if not. Sets the <code>written</code> flag on the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.printtoc-Tuple{JLD2.JLDFile}" href="#JLD2.printtoc-Tuple{JLD2.JLDFile}"><code>JLD2.printtoc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">printtoc([io::IO,] f::JLDFile [; numlines])</code></pre><p>Prints an overview of the contents of <code>f</code> to the <code>IO</code>.</p><p>Use the optional <code>numlines</code> parameter to restrict the amount of items listed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_array!" href="#JLD2.read_array!"><code>JLD2.read_array!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_array!(v::Array, f::JLDFile, rr)</code></pre><p>Fill the array <code>v</code> with the contents of JLDFile <code>f</code> at the current position, assuming a ReadRepresentation <code>rr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute, JLD2.H5Datatype, JLD2.ReadRepresentation}" href="#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute, JLD2.H5Datatype, JLD2.ReadRepresentation}"><code>JLD2.read_attr_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_attr_data(f::JLDFile, attr::ReadAttribute, expected_datatype::H5Datatype,
               rr::ReadRepresentation)</code></pre><p>jlread data from an attribute, assuming a specific HDF5 datatype and ReadRepresentation. If the HDF5 datatype does not match, throws an <code>UnsupportedFeatureException</code>. This allows better type stability while simultaneously validating the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute}" href="#JLD2.read_attr_data-Tuple{JLD2.JLDFile, JLD2.ReadAttribute}"><code>JLD2.read_attr_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_attr_data(f::JLDFile, attr::ReadAttribute)</code></pre><p>jlread data from an attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_compressed_array!" href="#JLD2.read_compressed_array!"><code>JLD2.read_compressed_array!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_compressed_array!(v::Array, f::JLDFile, rr, data_length::Int, ::Val{filter_id})</code></pre><p>Fill the array <code>v</code> with the compressed contents of JLDFile <code>f</code> at the current position, assuming a ReadRepresentation <code>rr</code> and that the compressed data has length <code>data_length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_data" href="#JLD2.read_data"><code>JLD2.read_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_data(f::JLDFile, dataspace::ReadDataspace, datatype_class::UInt8,
          datatype_offset::Int64, data_offset::Int64[, filter_id::UInt16,
          header_offset::RelOffset, attributes::Vector{ReadAttribute}])</code></pre><p>Read data from a file. If <code>datatype_class</code> is typemax(UInt8), the datatype is assumed to be committed, and <code>datatype_offset</code> points to the offset of the committed datatype&#39;s header. Otherwise, datatype_offset points to the offset of the datatype attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_scalar" href="#JLD2.read_scalar"><code>JLD2.read_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_scalar(f::JLDFile, rr, header_offset::RelOffset)</code></pre><p>Read raw data representing a scalar with read representation <code>rr</code> from the current position of JLDFile <code>f</code>. <code>header_offset</code> is the RelOffset of the object header, used to resolve cycles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.read_size-Tuple{IO, UInt8}" href="#JLD2.read_size-Tuple{IO, UInt8}"><code>JLD2.read_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_size(io::IO, flags::UInt8)</code></pre><p>Loads a variable-length size according to flags Expects that the first two bits of flags mean: 0   The size of the Length of Link Name field is 1 byte. 1   The size of the Length of Link Name field is 2 bytes. 2   The size of the Length of Link Name field is 4 bytes. 3   The size of the Length of Link Name field is 8 bytes. Returns the size as an Int</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.save_group-Tuple{JLD2.Group}" href="#JLD2.save_group-Tuple{JLD2.Group}"><code>JLD2.save_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_group(g::Group) -&gt; RelOffset</code></pre><p>Stores a group to a file, updating it if it has already been saved. Returns UNDEFINED_ADDRESS if the group was already stored, or the offset of the new group otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.save_object-Tuple{Any, Any}" href="#JLD2.save_object-Tuple{Any, Any}"><code>JLD2.save_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_object(filename, x)</code></pre><p>Stores an object <code>x</code> in a new JLD2 file at <code>filename</code>. If a file exists at this path, it will be overwritten.</p><p>Since the JLD2 format requires that all objects have a name, the object will be stored as <code>single_sotred_object</code>. If you want to store more than one object, use <a href="legacy/#JLD2.@save"><code>@save</code></a> macro, <a href="internals/#JLD2.jldopen"><code>jldopen</code></a> or the FileIO API.</p><p><strong>Example</strong></p><p>To save the string <code>hello</code> to the JLD2 file example.jld2:</p><pre><code class="language-none">hello = &quot;world&quot;
save_object(&quot;example.jld2&quot;, hello)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.symbol_length-Tuple{Symbol}" href="#JLD2.symbol_length-Tuple{Symbol}"><code>JLD2.symbol_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbol_length(x::Symbol)</code></pre><p>Returns the length of the string represented by <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.write_link-Tuple{Any, Any, Any}" href="#JLD2.write_link-Tuple{Any, Any, Any}"><code>JLD2.write_link</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_link(cio, name, offset)</code></pre><p>Write a link message at current position in <code>cio</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.@load-Tuple{Any, Vararg{Any}}" href="#JLD2.@load-Tuple{Any, Vararg{Any}}"><code>JLD2.@load</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@load filename var1 [var2 ...]</code></pre><p>Load one or more variables <code>var1,...</code> from JLD2 file <code>filename</code> into the current scope and return a vector of the loaded variable names.</p><p>For interactive use, the form <code>@load &quot;somefile.jld2&quot;</code> will load all variables from <code>&quot;somefile.jld2&quot;</code> into the current scope. This form only supports literal file names and should be avoided in more permanent code so that it&#39;s clear where the variables come from.</p><p><strong>Example</strong></p><p>To load the variables <code>hello</code> and <code>foo</code> from the file example.jld2, use</p><pre><code class="language-none">@load &quot;example.jld2&quot; hello foo</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JLD2.@save-Tuple{Any, Vararg{Any}}" href="#JLD2.@save-Tuple{Any, Vararg{Any}}"><code>JLD2.@save</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@save filename var1 [var2 ...]
@save filename {compress=true} var1 name2=var2</code></pre><p>Write one or more variables <code>var1,...</code> from the current scope to a JLD2 file <code>filename</code>.</p><p>For interactive use you can save all variables in the current module&#39;s global scope using <code>@save filename</code>. More permanent code should prefer the explicit form to avoid saving unwanted variables.</p><p><strong>Example</strong></p><p>To save the string <code>hello</code> and array <code>xs</code> to the JLD2 file example.jld2:</p><pre><code class="language-none">hello = &quot;world&quot;
xs = [1,2,3]
@save &quot;example.jld2&quot; hello xs</code></pre><p>For passing options to the saving command use {}</p><pre><code class="language-none">@save &quot;example.jld2&quot; {compress=true} hello xs</code></pre><p>For saving variables under a different name use regular assignment syntax</p><pre><code class="language-none">@save &quot;example.jld2&quot; greeting=hello xarray = xs</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/JLD2.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compression/">« Compression</a><a class="docs-footer-nextpage" href="../hdf5compat/">HDF5 Compatibility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 10 September 2022 08:33">Saturday 10 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
